                00001 ;main.asm
                00002 ;main routine for ZX Spectrum
                00003 ;(c) Evan Wright, 2017
                00004 
                00005 *INCLUDE objdefsZ80.asm
main.asm(5): unable to include file
                00006 
                00007 ; BASIC STARTS AT 5CCB for Spectrum
                00008         org 25000 ; 5CCBh  
                00009 start
                00010 
                00011 ;main program goes here
                00012 main
                00013                 ;set screen as output channel
61A8  CDAF0D    00014                 call 0DAFh  ; CLS
                00015                 ;call cls1
                00016                 
61AB  010000    00017                 ld bc,0
61AE  CD0570    00018                 call locate
                00019                 
61B1  210000    00020                 ld hl,welcome ; print welcome,author,version
main.asm(20): undefined symbol
61B4  CD4B62    00021                 call OUTLINCR
                00022  
61B7  210000    00023                 ld hl,author
main.asm(23): undefined symbol
61BA  CD4B62    00024                 call OUTLINCR
                00025  
61BD  210000    00026                 ld hl,version
main.asm(26): undefined symbol
61C0  CD4B62    00027                 call OUTLINCR
                00028  
61C3  CD9E63    00029                 call printcr
61C6  CD0000    00030                 call look_sub
main.asm(30): undefined symbol
                00031                 
                00032 $inp?    
61C9  DDE5      00033                 push ix
61CB  FDE5      00034                 push iy
                00035                 
61CD  CDD961    00036                 call getcommand
                00037  
61D0  FB        00038                 ei
                00039                 
61D1  FDE1      00040                 pop iy
61D3  DDE1      00041                 pop ix
                00042  
61D5  C3C961    00043                 jp $inp?
                00044         
61D8  C9        00045         ret
                00046 
                00047 getcommand
                00048                 ;call QINPUT
61D9  FB        00049                 ei
61DA  CD0C62    00050                 call getlin
61DD  F3        00051                 di      
61DE  CD5664    00052                 call parse                              ; get the words
                00053 ;               ld a,(sentence)
                00054 ;               cp 0
                00055 ;               jp z,$inp?  ;; HIGHLY SUSPICIOUS
                00056 ;               jp nz,$go?
                00057 ;               inc sp
                00058 ;               inc sp
                00059 ;               inc sp
                00060 ;               jp print_ret_pardon     
61E1  CD6466    00061 $go?    call validate_words             ; make sure verb,io,do are in tables
61E4  CDE666    00062                 call encode                             ; try to map words to objects
61E7  CD3966    00063                 call validate_encode    ; make sure it worked
61EA  CDDA69    00064                 call run_sentence
61ED  CDF461    00065                 call do_events
61F0  CDAF63    00066                 call draw_top_bar
61F3  C9        00067                 ret
                00068 
                00069 do_events
                00070 *INCLUDE event_jumps_Z80.asm
main.asm(70): unable to include file
61F4  CD0000    00071         call player_has_light
main.asm(71): undefined symbol
61F7  FE01      00072         cp 1
61F9  CA0662    00073         jp z,$y?
61FC  3A1472    00074         ld a,(turnsWithoutLight)
61FF  3C        00075         inc a
6200  321472    00076         ld (turnsWithoutLight),a
6203  C30B62    00077         jp $x?
6206  3E00      00078 $y?     ld a,0
6208  321472    00079         ld (turnsWithoutLight),a
620B  C9        00080 $x?     ret
                00081                 
                00082 *INCLUDE io.asm 
    = 0030      00083 BUFSIZE EQU 48
    = 000C      00084 DELETE EQU 12 
    = 003E      00085 PROMPT EQU 62
    = 5CD1      00086 CURMODE EQU 23761 ; K,
                00087 
                00088 *MOD
                00089 getlin
                00090                 ;clear buffer
620C  CD6262    00091                 call clrbuf
                00092                 
                00093                 ;output the prompt
620F  210F72    00094                 ld hl,curstr
6212  CD7570    00095                 call zx_printstr
                00096                 ;ld a,PROMPT
                00097                 ;rst 16
                00098                 
                00099                 ;loop until enter key is pressed
6215  CD8963    00100 $lp2A   call readkb
                00101                 
                00102                 ;convert to ASCII
6218  CD7562    00103                 call zx_to_ascii
                00104                 
621B  FE0C      00105                 cp 0Ch ; delete?
621D  C22662    00106                 jp nz,$sA
6220  CDB571    00107                 call back_up
6223  C31562    00108                 jp $lp2A
                00109                 
6226  FE0D      00110 $sA             cp 13   ; newline 
6228  CA4762    00111                 jp z,$outA
                00112 
                00113                 ;echo the char
                00114         
622B  F5        00115                 push af
622C  CD3270    00116                 call print1_zx
622F  F1        00117                 pop af
                00118                 
                00119  
                00120                 ;store the char in the input buffer
6230  F5        00121                 push af
6231  218962    00122                 ld hl,INBUF  ;add buffIx to start of buffer
6234  1600      00123                 ld d,0
6236  3A8862    00124                 ld a,(bufIx)
6239  5F        00125                 ld e,a
623A  19        00126                 add hl,de
623B  F1        00127                 pop af
                00128                 
623C  77        00129                 ld (hl),a ; now store the char
                00130                 
                00131                 ;increment the buffer index
623D  3A8862    00132                 ld a,(bufIx) 
6240  3C        00133                 inc a
6241  328862    00134                 ld (bufIx),a
                00135                                 
6244  C31562    00136                 jp $lp2A
                00137                 
                00138 $outA   ;ld a,13 ; echo a newline
                00139                 ;rst 16
6247  CDB070    00140                 call zx_newline
624A  C9        00141 $xA             ret
                00142 
                00143 
                00144 ;prints the string in (hl) followed
                00145 ;by a newline           
                00146 *MOD
                00147 OUTLINCR
624B  F5        00148                 push af
624C  C5        00149                 push bc
624D  D5        00150                 push de
624E  E5        00151                 push hl
624F  DDE5      00152                 push ix
6251  FDE5      00153                 push iy
6253  CD9863    00154                 call OUTLIN ; print (hl)
6256  CDB070    00155                 call zx_newline  ; move cursor
                00156                 ;ld     a,13  ; new line char
                00157                 ;ei
                00158                 ;rst 16  ; print char
                00159                 ;di
                00160                 ;call newline
6259  FDE1      00161                 pop iy
625B  DDE1      00162                 pop ix
625D  E1        00163                 pop hl
625E  D1        00164                 pop de
625F  C1        00165                 pop bc
6260  F1        00166                 pop af
6261  C9        00167                 ret
                00168 
                00169                 
                00170                 
                00171 *MOD
                00172 clrbuf
                00173 
                00174                 
                00175                 ;set index to 0
6262  3E00      00176                 ld a,0
6264  328862    00177                 ld (bufIx),a
                00178                 
                00179                 ;clear buffer
                00180  
6267  0600      00181                 ld b,0
6269  218962    00182                 ld hl,INBUF
                00183                 
626C  70        00184 $lpC    ld (hl),b
626D  23        00185                 inc hl
626E  3D        00186                 dec a
626F  FE00      00187                 cp 0
6271  C26C62    00188                 jp nz,$lpC
                00189                         
6274  C9        00190                 ret
                00191 
                00192                 
                00193 ;converts the character in 'a' to 
                00194 ;an uppercase ascii char.               
                00195 *MOD
                00196 zx_to_ascii
6275  FE61      00197                 cp 97  ; bail if < lowercase a
6277  DA8662    00198                 jp c,$xD        
627A  FE7A      00199                 cp 122 ; if greater than lowercase z, detokenize?
627C  D28462    00200                 jp nc,$scD
627F  D620      00201                 sub 32          ;make it uppercase      
6281  C38662    00202                 jp $xD
                00203 
                00204 $scD            
6284  D6A5      00205                 sub 165 ; convert to ascii
                00206 $xD             
6286  C9        00207                 ret
                00208 
                00209 
6287  00        00210           DB 0  ; padding - do not remove
6288  00        00211 bufIx DB 0
6289            00212 INBUF DS 256            
                00213 ;INBUF DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                00214 
                00215         
                00216 *INCLUDE input.asm
                00217 ;input routines for ZX Spectrum
                00218 ;(c) Evan Wright, 2017
                00219 
                00220 ;reads a single char and stores it in the
                00221 ;keyboard input buffer
                00222 readkb
6389  21085C    00223        ld hl,23560         ; LAST K system variable.
638C  3600      00224        ld (hl),0           ; put null value there.
638E  7E        00225 loop   ld a,(hl)           ; new value of LAST K.          
638F  FE00      00226        cp 0                ; is it still zero
6391  28FB      00227        jr z,loop           ; yes, so no key pressed.
6393  C9        00228            ret
                00229                 
                00230                 
                00231 *INCLUDE printing.asm
                00232 ;printing.asm
                00233 ;print routines for ZX spectrum
                00234 ;(c) Evan Wright, 2017
                00235 
    = 4000      00236 SCREEN equ 16384 ; 4000 hex
    = 02BE      00237 SCRSIZE equ 702 ; 32*22 line
    = 5C8D      00238 SCRCOLOR equ 23693
                00239 
                00240 ;output a char
                00241 CRTBYTE
6394  CD3270    00242                 call print1_zx
6397  C9        00243                 ret
                00244  
                00245 *MOD 
                00246 ;prints string in HL 
                00247 OUTLIN
6398  F5        00248                 push af
6399  CD7570    00249                 call zx_printstr
639C  F1        00250                 pop af
639D  C9        00251                 ret
                00252 
                00253 ;prints a space (registers are preserved)
                00254 printcr
639E  F5        00255         push af
639F  C5        00256         push bc
63A0  D5        00257         push de
63A1  FDE5      00258         push iy
                00259         ;ld a,0dh ; carriage return
                00260         ;call CRTBYTE
63A3  CDB070    00261         call zx_newline
63A6  CD7671    00262         call repos_cursor
63A9  FDE1      00263         pop iy
63AB  D1        00264         pop de
63AC  C1        00265         pop bc
63AD  F1        00266         pop af
63AE  C9        00267         ret     
                00268 
                00269 ;*MOD
                00270 ;CLS
                00271 ;               call 3503
                00272 ;               
                00273 ;               ;move cursor to top
                00274 ;$x?            ld a,0
                00275 ;               ld      (xcoord),a
                00276 ;               ld  (ycoord),a
                00277 ;               ret
                00278 
                00279 ;draws the bar at the top with the room and the score
                00280 *MOD
                00281 draw_top_bar
63AF  F5        00282                 push af
63B0  D5        00283                 push de
                00284                 
                00285                 ;save crsr x and y
63B1  ED5B0972  00286                 ld de,(CRSRY)
63B5  D5        00287                 push de
                00288 
63B6  010000    00289                 ld bc,0
63B9  ED430972  00290                 ld(CRSRY),bc
63BD  CD7671    00291                 call repos_cursor
                00292                 
                00293                 ;draw 32 inverse spaces
                00294                 
63C0  3E1F      00295                 ld a,31
63C2  F5        00296 $lpF    push af
63C3  3E00      00297                 ld a,0 ; BLACK SQUARE
63C5  CD3270    00298                 call print1_zx
63C8  F1        00299                 pop af
63C9  3D        00300                 dec a
63CA  FE00      00301                 cp 0
63CC  C2C263    00302                 jp nz,$lpF
                00303                 
                00304                 ;draw room name
63CF  0602      00305                 ld b,2
63D1  0E00      00306                 ld c,0
63D3  ED430972  00307                 ld (CRSRY),bc
63D7  CD7671    00308                 call repos_cursor
63DA  CD096C    00309                 call get_player_room
63DD  CD5F68    00310                 call print_obj_name
                00311                 
                00312                 ;draw score
63E0  061A      00313                 ld b,26
63E2  0E00      00314                 ld c,0
63E4  ED430972  00315                 ld (CRSRY),bc
63E8  CD7671    00316                 call repos_cursor
63EB  215164    00317                 ld hl,hundred
63EE  CD7570    00318                 call zx_printstr
                00319                 
63F1  CDFF63    00320                 call print_score ; print actual number
                00321                 
                00322                 ;restore cursor
63F4  D1        00323                 pop de
63F5  ED530972  00324                 ld (CRSRY),de
63F9  CD7671    00325                 call repos_cursor
                00326                 
63FC  D1        00327                 pop de
63FD  F1        00328                 pop af
                00329                 
63FE  C9        00330                 ret
                00331                 
                00332 ;prints the number to the top bar
                00333 *MOD
                00334 print_score
63FF  F5        00335                 push af
6400  C5        00336                 push bc
6401  D5        00337                 push de
                00338                 
                00339                 ;
6402  0619      00340                 ld b,25
6404  0E00      00341                 ld c,0
6406  ED430972  00342                 ld (CRSRY),bc
640A  CD7671    00343                 call repos_cursor
                00344                 
                00345                 ;print 1st char
640D  3A1172    00346                 ld a,(SCORE)
6410  060A      00347                 ld b,10
6412  CD0000    00348                 call mod ; a mod b
printing.asm(117): undefined symbol
6415  C630      00349                 add a,48
6417  CD3270    00350                 call print1_zx
                00351                                 
641A  CD4064    00352                 call backup_2
                00353                 
641D  3A1172    00354                 ld a,(SCORE)
6420  57        00355                 ld d,a
                00356                 
6421  7A        00357 $lpG    ld a,d
6422  060A      00358                 ld b,10
6424  CD0000    00359                 call div ; a div b
printing.asm(128): undefined symbol
6427  57        00360                 ld d,a ; save score             
                00361 
6428  FE00      00362                 cp 0
642A  CA3C64    00363                 jp z,$xG
                00364 
642D  CD0000    00365                 call mod ; a mod b
printing.asm(134): undefined symbol
6430  57        00366                 ld d,a  ; save score
6431  C630      00367                 add a,48
6433  CD3270    00368                 call print1_zx
6436  CD4064    00369                 call backup_2
                00370                 
6439  CA3C64    00371                 jp z,$xG
                00372                 
643C  D1        00373 $xG             pop de
643D  C1        00374                 pop bc
643E  F1        00375                 pop af
643F  C9        00376                 ret
                00377 
                00378 ;backs the cursor up 2
                00379 ;use to print the score
                00380 backup_2
6440  F5        00381         push af
6441  C5        00382         push bc
6442  A7        00383         and a ; clr flag
6443  3A0A72    00384         ld a,(CRSRX)
6446  DE02      00385         sbc a,2
6448  320A72    00386         ld (CRSRX),a
644B  CD7671    00387         call repos_cursor
644E  C1        00388         pop bc
644F  F1        00389         pop af
6450  C9        00390         ret
                00391         
6451  2F313030  00392 hundred DB "/100",0h     
      00                     
                00393 ;cursorPos DW SCREEN            
                00394 ;xcoord defb 0
                00395 ;ycoord defb 15
                00396  
                00397 *INCLUDE parser.asm
                00398 ;z80 parser 
                00399 *MOD
                00400 parse
6456  3E00      00401                 ld a,0  
6458  322868    00402                 ld (hit_end),a          ; clear flag                    ld (word_count),a       ; reset to 0
645B  212467    00403                 ld hl,word1     
645E  222468    00404                 ld (copydest),hl        ; set copy dest
6461  3A8962    00405                 ld a,(INBUF)            ; get 1st char? 
6464  FE00      00406                 cp 0            
6466  CAC864    00407                 jp z,$print_pardonH
6469  CD9565    00408                 call clear_buffers
646C  DD218962  00409                 ld ix,INBUF                ; set ix to input buffer
6470  FD218962  00410                 ld iy,INBUF                ; set iy to input buffer
6474  CDBA65    00411                 call move_to_next  ; move to end of 1st word    
6477  CD1D66    00412                 call store_word    ; save word 1        
647A  CDBA65    00413                 call move_to_next       ; try to bracket at 2nd word
647D  DD7E00    00414                 ld a,(ix) ;hit end? (single verb command)
6480  FE00      00415                 cp 0 
6482  CAC764    00416                 jp z,$_xH
6485  CD4165    00417                 call handle_prep ; compress preposition if needed and go to word 3
6488  214467    00418                 ld hl,word2              ; copy direct object   
648B  222468    00419                 ld (copydest),hl
648E  CDCD64    00420                 call skip_article       ; skip article if present
6491  DD7E00    00421                 ld a,(ix) ;hit end? (single verb command)
6494  FE00      00422                 cp 0 
6496  CAC764    00423                 jp z,$_xH
6499  CD1D66    00424                 call store_word         ; store direct object
649C  CDFD64    00425                 call find_preposition  ;stores prep
649F  3A2E68    00426                 ld a,(prep_found)
64A2  FE00      00427                 cp 0
64A4  CAC764    00428                 jp z, $_xH ; if no prep, we're done since we already have the d.o.
64A7  00        00429                 nop ; store prep and move past it, then get io 
64A8  DD7E00    00430                 ld a,(ix) ;hit end?
64AB  FE00      00431                 cp 0 
64AD  CAA66E    00432                 jp z,print_ret_no_io
64B0  CDCD64    00433                 call skip_article
64B3  DD7E00    00434                 ld a,(ix) ;hit end?
64B6  FE00      00435                 cp 0 
64B8  CAA66E    00436                 jp z,print_ret_no_io
64BB  FD7700    00437                 ld (iy),a
64BE  218467    00438                 ld hl,word4
64C1  222468    00439                 ld (copydest),hl
64C4  CD1D66    00440                 call store_word
64C7  C9        00441 $_xH    ret
                00442 $print_pardonH
64C8  33        00443                 inc sp
64C9  33        00444                 inc sp
64CA  C39C6E    00445                 jp print_ret_pardon
                00446                 
                00447 ;skip_article
                00448 ;moves to the next word, if that word is an article
                00449 ;if it's not the last word
                00450 ;ix must point to the word to look at
                00451 ;ix are positioned at the start of the next word
                00452 *MOD
                00453 skip_article
64CD  F5        00454                 push af
64CE  D5        00455                 push de
64CF  E5        00456                 push hl
64D0  FD7E00    00457                 ld a,(iy)       
64D3  57        00458                 ld d,a  ;save char (null or space)
64D4  3E00      00459                 ld a,0  ;put a null there       
64D6  FD7700    00460                 ld (iy),a
64D9  FDE5      00461                 push iy 
64DB  FD210000  00462                 ld iy,article_table ; iy is table to search
parser.asm(65): undefined symbol
64DF  CDB368    00463                 call get_table_index
64E2  FDE1      00464                 pop iy
64E4  FD7200    00465                 ld (iy),d ;replace null or space
64E7  78        00466                 ld a,b
64E8  FEFF      00467                 cp 0ffh  ; not found -> take no action
64EA  CAF964    00468                 jp z,$xI                
64ED  210F67    00469                 ld hl,DbgSA
64F0  CD9863    00470                 call OUTLIN
64F3  CD9E63    00471                 call printcr
64F6  CDBA65    00472                 call move_to_next ; move to end of next word
64F9  E1        00473 $xI             pop hl
64FA  D1        00474                 pop de
64FB  F1        00475                 pop af
64FC  C9        00476                 ret
                00477 
                00478 ;this subroutin e looks for a preposition
                00479 ;if a prep is found, prep_found is set to 1,
                00480 ;and the prep id is stored in sentence+2
                00481 *MOD
                00482 find_preposition
64FD  F5        00483                 push af
64FE  C5        00484                 push bc
64FF  D5        00485                 push de
6500  E5        00486                 push hl
6501  DD7E00    00487 $lpJ    ld a,(ix)
6504  FE00      00488                 cp 0
6506  CA3C65    00489                 jp z,$xJ
6509  CDBA65    00490                 call move_to_next
650C  FD5600    00491                 ld d,(iy)       ; save char we're going to null out
650F  FD360000  00492                 ld (iy),0   ;null out end of word
6513  FDE5      00493                 push iy
6515  FD210000  00494                 ld iy,prep_table
parser.asm(97): undefined symbol
6519  CDB368    00495                 call get_table_index
651C  FDE1      00496                 pop iy          ;
651E  FD7200    00497                 ld (iy),d       ; restore byte
6521  78        00498                 ld a,b          ; move result to a
6522  FEFF      00499                 cp 0ffh
6524  CA0165    00500                 jp z,$lpJ   ; if not prep hit, repeat
6527  00        00501                 nop             ; hit a preposition
6528  216467    00502                 ld hl,word3
652B  222468    00503                 ld (copydest),hl
652E  CD1D66    00504                 call store_word
6531  322C68    00505                 ld (sentence+2),a
6534  3E01      00506                 ld a,1
6536  322E68    00507                 ld (prep_found),a 
6539  CDBA65    00508                 call move_to_next ; find next word
653C  E1        00509 $xJ             pop hl
653D  D1        00510                 pop de
653E  C1        00511                 pop bc
653F  F1        00512                 pop af
6540  C9        00513                 ret
                00514 
                00515 ;if the word between ix and iy is a prep, the 
                00516 ;word is stuck on the end of word 1 and ix,iy
                00517 ;are moved to bracket the next word
                00518 ;and word 2 is zeroed out.
                00519 *MOD
                00520 handle_prep
6541  F5        00521         push af
6542  C5        00522         push bc
6543  D5        00523         push de
6544  E5        00524         push hl
6545  FDE5      00525         push iy
6547  FD5600    00526         ld d,(iy) ; save char at end of word1
654A  FD360000  00527         ld (iy),0 ; null terminate word for string cmp
654E  FD210000  00528         ld iy,prep_table
parser.asm(131): undefined symbol
6552  CDB368    00529         call get_table_index    
6555  FDE1      00530         pop iy
6557  78        00531         ld a,b
6558  FEFF      00532         cp 0ffh ; found?
655A  CA6965    00533         jp z,$xK ; exit on not found
                00534 ;       ld hl,DbgPF
                00535 ;       call OUTLIN
655D  CD7165    00536         call move_prep ; doesn't change ix,iy
6560  FD7200    00537         ld (iy),d       ; restore null or space
6563  CDBA65    00538         call move_to_next ; move to next word
6566  C36C65    00539         jp $yK
6569  FD7200    00540 $xK     ld (iy),d       ; restore null or space
656C  E1        00541 $yK     pop hl
656D  D1        00542         pop de
656E  C1        00543         pop bc
656F  F1        00544         pop af
6570  C9        00545         ret
                00546 
                00547 ;moves word pointed to by ix
                00548 ;to the end of the word1 buffer
                00549 move_prep
6571  DDE5      00550                 push ix                                 ; 2nd word was a prep
6573  FDE5      00551                 push iy
6575  D5        00552                 push de
6576  3A2868    00553                 ld a,(hit_end)  ; save old flag
6579  57        00554                 ld d,a
657A  FD212467  00555                 ld iy,word1
657E  CDE765    00556                 call move_to_end
6581  3E20      00557                 ld a,20h ; space
6583  FD7700    00558                 ld (iy),a ; overwrite null with space
6586  FD23      00559                 inc iy    ;move past space
6588  CD8569    00560                 call strcpyi
658B  7A        00561                 ld a,d
658C  322868    00562                 ld (hit_end),a
658F  D1        00563                 pop de
6590  FDE1      00564                 pop iy
6592  DDE1      00565                 pop ix
6594  C9        00566                 ret
                00567 
                00568 
                00569                 
                00570 ;clears the variables where the words are stored
                00571 clear_buffers
6595  3E00      00572                 ld a,0                          ; clear the 
6597  322E68    00573                 ld (prep_found),a
659A  3EFF      00574                 ld a,0ffh
659C  322A68    00575                 ld (sentence),a
659F  322B68    00576                 ld (sentence+1),a
65A2  322C68    00577                 ld (sentence+2),a
65A5  322D68    00578                 ld (sentence+3),a
65A8  0600      00579                 ld b, 0
65AA  DD212368  00580                 ld ix,copydest-1
65AE  DD7000    00581 $lp     ld (ix),b
65B1  DD2B      00582                 dec ix
65B3  3D        00583                 dec a
65B4  FE00      00584                 cp 0
65B6  C2AE65    00585                 jp nz,$lp
65B9  C9        00586                 ret
                00587                 
                00588 ;brackets the next word with ix,iy              
                00589 move_to_next
65BA  FDE5      00590         push iy ; move ix to end of last word
65BC  DDE1      00591         pop ix
65BE  DD7E00    00592         ld a,(ix)
65C1  FE00      00593         cp 0  ; null?
65C3  C8        00594         ret z   
65C4  CDCB65    00595         call move_to_start ; move to start of text
65C7  CDE765    00596         call move_to_end ; move to start of text
65CA  C9        00597         ret
                00598         
                00599 ;skips over spaces until ix points
                00600 ;to a non space
                00601 ;uses a,ix      
                00602 *MOD
                00603 move_to_start
65CB  F5        00604                 push af
65CC  DD7E00    00605 $_lp    ld a,(ix)
65CF  FE20      00606                 cp 20h          ; space?
65D1  CADC65    00607                 jp z,$cntL      ; quit
65D4  FE00      00608                 cp 0            ; null?
65D6  CADC65    00609                 jp z,$cntL      ; quit
65D9  C3E165    00610                 jp $xL
65DC  DD23      00611 $cntL   inc ix          ;next char
65DE  C3CC65    00612                 jp $_lp         ;repeat
65E1  DDE5      00613 $xL             push ix ;copy ix to iy
65E3  FDE1      00614                 pop iy  ;iy needs to catch up
65E5  F1        00615                 pop af
65E6  C9        00616                 ret
                00617 
                00618 ;moves iy to the 1st space or null at the end of 
                00619 ;a word.  Assumes iy is already pointing to the
                00620 ;start of the word
                00621 ;uses iy
                00622 ;if null is hit, hit_end is set to 1
                00623 *MOD
                00624 move_to_end
65E7  F5        00625                         push af
65E8  FD7E00    00626 $_lpM           ld a,(iy)       ; get char
65EB  CDCD69    00627                         call atoupper
65EE  FD7700    00628                         ld (iy),a
65F1  FE20      00629                         cp 20h          ; space?
65F3  CA0566    00630                         jp z, $_x
65F6  FE00      00631                         cp 0            ; null
65F8  CA0066    00632                         jp z, _heM
65FB  FD23      00633                         inc iy
65FD  C3E865    00634                         jp $_lpM
6600  3E01      00635 _heM            ld a,1
6602  322868    00636                         ld (hit_end),a
6605  F1        00637 $_x                     pop af
6606  C9        00638                         ret
                00639 ;read do
                00640 *MOD    
                00641 read_dobj
6607  3A2868    00642         ld a,(hit_end)
660A  FE01      00643         cp 1
660C  C8        00644         ret z
                00645         ;       call skip_article  ; call skip_article
660D  214467    00646         ld hl,word2
6610  222468    00647         ld (copydest),hl
6613  CDCB65    00648         call move_to_start
6616  CDE765    00649         call move_to_end
6619  CD1D66    00650         call store_word
661C  C9        00651         ret
                00652                         
                00653 ;copies from (iy-ix) chars from ix to copydest
                00654 store_word 
661D  C5        00655                 push bc
661E  D5        00656                 push de
661F  E5        00657                 push hl
6620  37        00658                 scf     ;clear the carry flag by setting it...
6621  3F        00659                 ccf ;then flipping it
6622  FDE5      00660                 push iy ; copy iy to hl
6624  E1        00661                 pop hl
6625  DDE5      00662                 push ix ; copy ix to bc
6627  C1        00663                 pop bc
6628  ED42      00664                 sbc hl,bc
662A  E5        00665                 push hl ; byte count to bc
662B  C1        00666                 pop bc
662C  DDE5      00667                 push ix  ; ix->hl       
662E  E1        00668                 pop hl
662F  ED5B2468  00669                 ld de,(copydest)
6633  EDB0      00670                 ldir            ; (hl)->(de) until bc=0
6635  E1        00671                 pop hl
6636  D1        00672                 pop de
6637  C1        00673                 pop bc
6638  C9        00674                 ret
                00675 
                00676 
                00677 *MOD
                00678 ;Checks to see that io and do were succesfully mapped
                00679 ;to visible objects.  This has to be done because the
                00680 ;parser may recognize a word, but it doesn't refer to
                00681 ;a visible object.
                00682 ;If validate fails, subroutine calls print_ret_dont_see
                00683 ;pops the stack and returns to the parsing loop
                00684 *MOD
                00685 validate_encode
6639  3A4467    00686                 ld a,(word2) ; is the word blank(null)
663C  FE00      00687                 cp 0
663E  CA6366    00688                 jp z,$xP
6641  3A2B68    00689                 ld a,(sentence+1)
6644  FEFF      00690                 cp 255
6646  C24E66    00691                 jp nz,$w4P
6649  33        00692                 inc sp
664A  33        00693                 inc sp
664B  C3F26E    00694                 jp print_ret_dont_see
664E  3A8467    00695 $w4P    ld a,(word4)  ; is there an io?
6651  FE00      00696                 cp 0
6653  CA6366    00697                 jp z,$xP
6656  3A2D68    00698                 ld a,(sentence+3)
6659  FEFF      00699                 cp 255
665B  C26366    00700                 jp nz,$xP
665E  33        00701                 inc sp
665F  33        00702                 inc sp
6660  C3F26E    00703                 jp print_ret_dont_see   
6663  C9        00704 $xP             ret
                00705                 
                00706 ;validates that the io and do exist in the tables               
                00707 *MOD
                00708 validate_words
6664  3EFF      00709                 ld a,255
6666  322A68    00710                 ld (sentence),a
6669  323068    00711                 ld (doWordId),a
666C  323168    00712                 ld (ioWordId),a
666F  00        00713                 nop ; there is always a verb
6670  CD2B69    00714                 call get_verbs_id 
6673  FEFF      00715                 cp 0ffh
6675  C27D66    00716                 jp nz,$doQ
6678  33        00717                 inc sp  ; return from caller
6679  33        00718                 inc sp
667A  C3B06E    00719                 jp print_ret_bad_verb
667D  322A68    00720 $doQ    ld (sentence),a ; store verb
6680  3A4467    00721                 ld a,(word2) ; is there a 1st word?
6683  FE00      00722                 cp 0
6685  CAC566    00723                 jp z,$xQ
6688  DD214467  00724                 ld ix,word2
668C  FD210000  00725                 ld iy,dictionary
parser.asm(328): undefined symbol
6690  CDB368    00726                 call get_table_index ; result in a
6693  78        00727                 ld a,b
6694  323068    00728                 ld (doWordId),a
6697  FEFF      00729                 cp 0ffh  ; was it found
6699  C2A366    00730                 jp nz,$ioQ
669C  00        00731                 nop ; look up obj and store it in sentence+1
669D  33        00732                 inc sp
669E  33        00733                 inc sp
669F  C3C66E    00734                 jp print_ret_bad_do ; returns
66A2  00        00735                 nop ; now validate io
66A3  3A8467    00736 $ioQ    ld a,(word4) ; is there a 1st word
66A6  FE00      00737                 cp 0
66A8  CAC566    00738                 jp z,$xQ
66AB  DD218467  00739                 ld ix,word4
66AF  FD210000  00740                 ld iy,dictionary
parser.asm(343): undefined symbol
66B3  CDB368    00741                 call get_table_index ; result in a
66B6  78        00742                 ld a,b
66B7  323168    00743                 ld (ioWordId),a
66BA  FEFF      00744                 cp 0ffh  ; was it found
66BC  C2C566    00745                 jp nz,$xQ
66BF  00        00746                 nop ; look up obj and store it in sentence+1
66C0  33        00747                 inc sp
66C1  33        00748                 inc sp
66C2  C3DC6E    00749                 jp print_ret_bad_io ; returns
66C5  C9        00750 $xQ             ret             
                00751 
                00752 ;attempts to find an object that matches the word
                00753 ;entered by the user.  If no visible objects match,
                00754 ;FF is returned.        
                00755 *MOD
                00756 lkp_directobj
66C6  F5        00757                 push af
66C7  C5        00758                 push bc
66C8  3A3068    00759                 ld a,(doWordId)
66CB  47        00760                 ld b,a
66CC  CDE068    00761                 call get_obj_id ; 'get the object with that word'
66CF  78        00762                 ld a,b
66D0  322B68    00763                 ld (sentence+1),a ; copy of b
66D3  C1        00764                 pop bc
66D4  F1        00765                 pop af
66D5  C9        00766                 ret
                00767                 
                00768                 
                00769 *MOD
                00770 lkp_indirectobj
66D6  F5        00771                 push af
66D7  C5        00772                 push bc
66D8  3A3168    00773                 ld a,(ioWordId)
66DB  47        00774                 ld b,a
66DC  CDE068    00775                 call get_obj_id ; 'get the object with that word'
66DF  78        00776                 ld a,b
66E0  322D68    00777                 ld (sentence+3),a ; copy of b
66E3  C1        00778                 pop bc
66E4  F1        00779                 pop af
66E5  C9        00780                 ret
                00781 
                00782 ;
                00783 ;looks at each word in sentence and
                00784 ;tries to convert it to an object or verb id
                00785 encode
66E6  F5        00786                 push af
66E7  3A4467    00787                 ld a,(word2) ; is the an d.o?
66EA  FE00      00788                 cp 0
66EC  CAFE66    00789                 jp z,$xS
66EF  CDC666    00790                 call lkp_directobj
66F2  00        00791                 nop ; prep is already stored by parser
66F3  3A8467    00792                 ld a,(word4) ; is the an i.o?
66F6  FE00      00793                 cp 0
66F8  CAFE66    00794                 jp z,$xS
66FB  CDD666    00795                 call lkp_indirectobj
66FE  F1        00796 $xS             pop af
66FF  C9        00797                 ret
                00798         
                00799 
                00800         
6700  4442473A  00801 DbgPF DB "DBG:PREP FOUND",0h            
      50 52 45 50 20 46 4F 55
      4E 44 00               
670F  4442473A  00802 DbgSA DB "DBG:SKIPPING ARTICLE",0h              
      53 4B 49 50 50 49 4E 47
      20 41 52 54 49 43 4C 45
      00                     
                00803                 
6724            00804 word1 DS 32
6744            00805 word2 DS 32
6764            00806 word3 DS 32
6784            00807 word4 DS 32
67A4            00808 word5 DS 32
67C4            00809 word6 DS 32
67E4            00810 word7 DS 32
6804            00811 word8 DS 32
6824  0000      00812 copydest DW 0000h
6826  0000      00813 prepaddr DW 0000h
6828  00        00814 hit_end DB 0
6829  00        00815 word_count DB 0
682A            00816 sentence DS 4
                00817 
682E  00        00818 prep_found DB 0
682F  00        00819 parse_err DB 0
                00820 
6830  FF        00821 doWordId DB 255
6831  FF        00822 ioWordId DB 255
                00823 *INCLUDE look.asm
main.asm(86): unable to include file
                00824 *INCLUDE tables.asm
                00825 ;z80 table searching routines
                00826 
                00827 
                00828 ;prints an entry in the table
                00829 ;b contains the number of the string to print
                00830 ;ix contains table address
                00831 *MOD
                00832 print_table_entry
6832  F5        00833         push af
6833  C5        00834         push bc
6834  D5        00835         push de
6835  E5        00836         push hl
6836  DDE5      00837         push ix
6838  3E00      00838         ld a,0d ; lp counter 
683A  B8        00839 _lp     cp b    ; compare accumulator to a
683B  C24968    00840         jp nz,_sk ; skip this entry
683E  DD23      00841         inc ix  ; skip length byte
6840  DDE5      00842         push ix ; move string addr to hl
6842  E1        00843         pop hl
6843  CD9863    00844         call OUTLIN
6846  C35868    00845         jp _x
6849  3C        00846 _sk     inc a           ; increment loop counter
684A  DD5E00    00847         ld      e,(ix+0) ; load length byte
684D  1600      00848         ld d,0
684F  DD19      00849         add ix,de  ; add it to ix (skip string)
6851  DD23      00850         inc ix     ; add 1 to skip length byte
6853  DD23      00851         inc ix     ; add 1 to skip null terminator
6855  C33A68    00852         jp _lp
6858  DDE1      00853 _x      pop ix
685A  E1        00854         pop hl
685B  D1        00855         pop de
685C  C1        00856         pop bc
685D  F1        00857         pop af
685E  C9        00858         ret
                00859 
                00860 ;prints the name of the object whose
                00861 ;id is supplied in register 'a'
                00862 *MOD
                00863 print_obj_name
685F  F5        00864                 push af
6860  C5        00865                 push bc
6861  D5        00866                 push de
6862  DDE5      00867                 push ix
6864  DD210000  00868                 ld ix,obj_word_table
tables.asm(44): undefined symbol
6868  110400    00869                 ld de,4         ; step amount through table
686B  FE00      00870 _lp$    cp 0            ; done?
686D  CA7668    00871                 jp z,_out$
6870  DD19      00872                 add ix,de
6872  3D        00873                 dec a           ; dec loop counter              
6873  C36B68    00874                 jp _lp$
6876  DD23      00875 _out$   inc ix          ; skip past the id byte to the words
6878  0600      00876                 ld b,0
687A  78        00877 _l2$    ld a,b
687B  FE03      00878                 cp 3            ; hit 3 word max?
687D  CA9F68    00879                 jp z,_xU
6880  DD7E00    00880                 ld a,(ix)       ; get word id
6883  FEFF      00881                 cp 255d         ; done (empty entry)?
6885  CA9F68    00882                 jp z,_xU        
6888  C5        00883                 push bc         ;save loop counter
6889  47        00884                 ld b,a          ; put word id in b
688A  DDE5      00885                 push ix         ; save ix
688C  DD210000  00886                 ld ix,dictionary        
tables.asm(62): undefined symbol
6890  CD3268    00887                 call print_table_entry
6893  CDA568    00888                 call print_space
6896  DDE1      00889                 pop ix          ; restore ix (our table index)
6898  DD23      00890                 inc ix          ; move to next word id
689A  C1        00891                 pop bc          ; restore loop counter
689B  04        00892                 inc b
689C  C37A68    00893                 jp _l2$ 
689F  DDE1      00894 _xU             pop ix
68A1  D1        00895                 pop de
68A2  C1        00896                 pop bc
68A3  F1        00897                 pop af
68A4  C9        00898                 ret
                00899         
                00900 ;prints a space (registers are preserved)
                00901 print_space
68A5  C5        00902         push bc
68A6  D5        00903         push de
68A7  FDE5      00904         push iy
68A9  3E20      00905         ld a,20h        ; ascii space
68AB  CD9463    00906         call CRTBYTE
68AE  FDE1      00907         pop iy
68B0  D1        00908         pop de
68B1  C1        00909         pop bc
68B2  C9        00910         ret
                00911 
                00912 
                00913 ;get table index
                00914 ;returns the table index in the word in b (or ff if not found)
                00915 ;ix contains the address of the word to find
                00916 ;iy contains the address of the table to search
                00917 ;c is clobbered
                00918 *MOD
                00919 get_table_index
68B3  D5        00920                 push de
68B4  0600      00921                 ld b,0
68B6  FD7E00    00922 $_lpV   ld a,(iy)
68B9  FEFF      00923                 cp 255 ; hit end
68BB  CADC68    00924                 jp z,$_nfV
68BE  FD23      00925                 inc     iy ; skip len byte
68C0  CDA569    00926                 call streq ; test equality - result in a
68C3  FE01      00927                 cp 1    ; done - b contains index
68C5  CADE68    00928                 jp z,$_xV       ;jump if found
68C8  04        00929                 inc b           ;update loop counter (index)
68C9  FD2B      00930                 dec iy          ;back up an get length byte
68CB  1600      00931                 ld d,0
68CD  FD5E00    00932                 ld e,(iy)
68D0  FD19      00933                 add iy,de       ; skip to next string
68D2  FD23      00934                 inc iy          ; skip length byte
68D4  FD23      00935                 inc iy          ; skip null
68D6  C3B668    00936                 jp $_lpV        ;repeat
68D9  C3DE68    00937                 jp $_xV
68DC  06FF      00938 $_nfV   ld b,255                
68DE  D1        00939 $_xV    pop de
68DF  C9        00940                 ret
                00941         
                00942 ;returns the object id for the object whose
                00943 ;'word' is supplied in b
                00944 ;the value replaces the parameter
                00945 ;only visible objects will be considered
                00946 ;c is clobbered
                00947 *MOD
                00948 get_obj_id
68E0  F5        00949                 push af
68E1  D5        00950                 push de
68E2  DDE5      00951                 push ix
68E4  50        00952                 ld d,b ; word id to 'd'
68E5  CD096C    00953                 call get_player_room
68E8  47        00954                 ld b,a ; save it in b
68E9  DD210000  00955                 ld ix,obj_word_table
tables.asm(131): undefined symbol
68ED  DD7E00    00956 $lpW    ld a,(ix)       ; hit end of table?
68F0  FEFF      00957                 cp 255
68F2  CA2469    00958                 jp z,$nfW
68F5  4F        00959                 ld c,a ; the current object
68F6  CD176C    00960                 call b_ancestor_of_c  ; reslt->a. Note this should really check visibility
68F9  FE00      00961                 cp 0
68FB  CA1369    00962                 jp z,$cW    ; can't see it - go to next obj
68FE  DD7E01    00963                 ld a,(ix+1)     ;  get word entry
6901  BA        00964                 cp d            ;  equal to supplied word?
6902  CA1E69    00965                 jp z, $_yW
6905  DD7E02    00966                 ld a,(ix+2)             ; get lp counter
6908  BA        00967                 cp d            ;  equal to supplied word?
6909  CA1E69    00968                 jp z, $_yW
690C  DD7E03    00969                 ld a,(ix+3)     ;get object's word entry
690F  BA        00970                 cp d            ;  equal to supplied word?
6910  CA1E69    00971                 jp z, $_yW
6913  DD23      00972 $cW             inc ix          ; not found. increment ix to next entry
6915  DD23      00973                 inc ix          
6917  DD23      00974                 inc ix          
6919  DD23      00975                 inc ix          
691B  C3ED68    00976                 jp $lpW ; go to next object
691E  DD4600    00977 $_yW    ld b,(ix)       ; they match! back up put the id in b
6921  C32669    00978                 jp $_xW
6924  06FF      00979 $nfW    ld b,255        ; not found code
6926  DDE1      00980 $_xW    pop ix
6928  D1        00981                 pop de
6929  F1        00982                 pop af
692A  C9        00983                 ret
                00984 
                00985 
                00986 ;get_verb_id
                00987 ;the verb is assumed to be in word1
                00988 ;returns the id # of the verb in a
                00989 *MOD
                00990 get_verbs_id
692B  C5        00991                 push bc
692C  D5        00992                 push de
692D  E5        00993                 push hl
692E  DDE5      00994                 push ix
6930  FDE5      00995                 push iy
6932  FD212467  00996                 ld iy,word1
6936  DD210000  00997                 ld ix,verb_table
tables.asm(173): undefined symbol
693A  DD7E00    00998 $lpX    ld a,(ix)       ;save the id byte
693D  47        00999                 ld b,a
693E  FEFF      01000                 cp 0ffh 
6940  CA5F69    01001                 jp z, $xX               ; hit end of table
6943  1600      01002                 ld d,0                  ; set up de with len
6945  DD23      01003                 inc ix
6947  DD5E00    01004                 ld e,(ix)               ; get length byte
694A  DD23      01005                 inc ix                  ;ix now at text
694C  CDA569    01006                 call streq
694F  FE01      01007                 cp 1   
6951  CA5F69    01008                 jp z,$xX
6954  DDE5      01009                 push ix         ;move ix to hl
6956  E1        01010                 pop hl
6957  19        01011                 add hl,de       ; skip text (add length)
6958  23        01012                 inc hl          ; skip null
6959  E5        01013                 push hl         ;transfer back to 2
695A  DDE1      01014                 pop ix  ; ix is always 2 bytes past hl
695C  C33A69    01015                 jp $lpX
695F  78        01016 $xX             ld a,b
6960  FDE1      01017                 pop iy
6962  DDE1      01018                 pop ix
6964  E1        01019                 pop hl
6965  D1        01020                 pop de
6966  C1        01021                 pop bc
6967  C9        01022                 ret
                01023                 
                01024 *INCLUDE strings.asm
                01025 ;z80 parser
                01026 ;returns len of str in hl in bc
                01027 *MOD
                01028 strlen
6968  F5        01029                 push af
6969  E5        01030                 push hl
696A  010000    01031                 ld bc,0
696D  7E        01032 $lpY    ld a,(hl)
696E  03        01033                 inc bc  ; inc char to copy
696F  23        01034                 inc hl  ; inc index
6970  FE00      01035                 cp 0d  ; hit null?
6972  CA7869    01036                 jp z,$xY
6975  C36D69    01037                 jp $lpY
6978  E1        01038 $xY             pop hl
6979  F1        01039                 pop af
697A  C9        01040                 ret
                01041  
                01042 ;moves the string from hl to de
                01043 *MOD
                01044 strcpy
697B  F5        01045         push af
697C  C5        01046         push bc
697D  CD6869    01047         call strlen ; puts len in bc
6980  EDB0      01048         ldir            ; copy bc chars from hl to de
6982  C1        01049         pop bc
6983  F1        01050         pop af
6984  C9        01051         ret
                01052         
                01053 ;copies string in ix
                01054 ;to iy
                01055 strcpyi
6985  F5        01056         push af
6986  DDE5      01057         push ix
6988  FDE5      01058         push iy
698A  DD7E00    01059 lpZ ld a,(ix)
698D  FD7700    01060         ld (iy),a
6990  FE00      01061         cp 0            ; null?
6992  CA9F69    01062         jp z,$_xZ
6995  DD23      01063         inc ix
6997  FD23      01064         inc iy
6999  CA9F69    01065         jp z,$_xZ
699C  C38A69    01066         jp lpZ
699F  FDE1      01067 $_xZ    pop iy
69A1  DDE1      01068         pop ix
69A3  F1        01069         pop af
69A4  C9        01070         ret     
                01071 
                01072 ;compares string in ix and iy
                01073 ;returns 1 or 0 in a
                01074 *MOD
                01075 streq
69A5  C5        01076         push bc
69A6  DDE5      01077         push ix
69A8  FDE5      01078         push iy
69AA  DD7E00    01079 $lpBA ld a,(ix) ; get a byte
69AD  DD23      01080         inc ix
69AF  FD4600    01081         ld b,(iy) ; compare it
69B2  FD23      01082         inc iy
69B4  B8        01083         cp b
69B5  C2C569    01084         jp nz,$nBA
69B8  FE00      01085         cp 0; they were equal. hit end$
69BA  CAC069    01086         jp z,$yBA
69BD  C3AA69    01087         jp $lpBA ; repeat       
69C0  3E01      01088 $yBA  ld a,1
69C2  C3C769    01089     jp $xBA     
69C5  3E00      01090 $nBA    ld a,0
69C7  FDE1      01091 $xBA    pop iy
69C9  DDE1      01092         pop ix
69CB  C1        01093         pop bc
69CC  C9        01094         ret 
                01095 
                01096         
                01097         
                01098 ;;;;;;;;;;;;;;;;;;;;;;;;;;
                01099 ;Converts a to upper case
                01100 ;;;;;;;;;;;;;;;;;;;;;;;;;;
                01101 *MOD
                01102 atoupper
69CD  FE61      01103         cp 97
69CF  FAD969    01104         jp m,$xBB
69D2  FE7A      01105         cp 122
69D4  F2D969    01106         jp p,$xBB
69D7  D620      01107         sub 32
69D9  C9        01108 $xBB    ret
                01109 
                01110 *INCLUDE checksZ80.asm
main.asm(89): unable to include file
                01111 *INCLUDE sentencesZ80.asm
                01112 ;sentences running routines
                01113 *MOD
                01114 run_sentence
                01115                 ;run checks (these return if not met)           
69DA  DD210000  01116                 ld ix,check_table
sentencesZ80.asm(5): undefined symbol
69DE  DD7E00    01117 $lpBC   ld a,(ix)
69E1  FEFF      01118                 cp 255
69E3  CA076A    01119                 jp z,$dBC
69E6  3A2A68    01120                 ld a,(sentence)
69E9  DDBE00    01121                 cp (ix) ; compare to verb
69EC  C2FE69    01122                 jp nz,$cBC
69EF  DD23      01123                 inc ix
69F1  21FC69    01124                 ld hl,$nxtBC
69F4  E5        01125                 push hl  ; "call" to check rountine
69F5  DD6E00    01126                 ld l,(ix)
69F8  DD6601    01127                 ld h,(ix+1)
69FB  E9        01128                 jp (hl)
69FC  DD2B      01129 $nxtBC  dec ix
69FE  DD23      01130 $cBC            inc ix  ; skip to next entry
6A00  DD23      01131                 inc ix
6A02  DD23      01132                 inc ix
6A04  C3DE69    01133                 jp $lpBC
6A07  00        01134 $dBC            nop;
                01135                 ;return before
6A08  DD210000  01136                 ld ix,preactions_table
sentencesZ80.asm(25): undefined symbol
6A0C  CD266A    01137                 call run_actions
                01138                 ;run instead
6A0F  DD210000  01139                 ld ix,actions_table
sentencesZ80.asm(28): undefined symbol
6A13  CD266A    01140                 call run_actions
6A16  3AAB6A    01141                 ld a,(action_run)
6A19  FE01      01142                 cp 1
6A1B  C4AC6A    01143                 call nz,run_default_sentence
                01144                 ;run 'after' actions
6A1E  DD210000  01145                 ld ix,postactions_table
sentencesZ80.asm(34): undefined symbol
6A22  CD266A    01146                 call run_actions
6A25  C9        01147                 ret
                01148 
                01149 ;actions table in ix
                01150 ;post condition: action_run = 1
                01151 ;if a sentence was run
                01152 ;if an exact match isn't found,
                01153 ;an attempt is match to find and run
                01154 ;a wildcard match using the same table
                01155 *MOD
                01156 run_actions
6A26  DDE5      01157         push ix
6A28  FDE5      01158         push iy
6A2A  FD212A68  01159         ld iy,sentence
6A2E  CD4D6A    01160         call run_actions_
                01161         
6A31  3AAB6A    01162         ld a,(action_run)
6A34  FE01      01163         cp 1
6A36  CA486A    01164         jp z,$xBD
                01165         
6A39  FDE1      01166         pop iy          ;reload ix,iy
6A3B  DDE1      01167         pop ix
6A3D  DDE5      01168         push ix
6A3F  FDE5      01169         push iy
                01170         
6A41  FD216A6B  01171         ld iy,wildcards
6A45  CDDF6A    01172         call run_wildcards      
6A48  FDE1      01173 $xBD    pop iy
6A4A  DDE1      01174         pop ix
6A4C  C9        01175         ret
                01176 
                01177 ;runs exact match sentences from the
                01178 ;table pointed to by ix
                01179 *MOD
                01180 run_actions_
6A4D  C5        01181                 push bc
6A4E  D5        01182                 push de
6A4F  E5        01183                 push hl
6A50  DDE5      01184                 push ix 
6A52  FDE5      01185                 push iy 
6A54  3E00      01186                 ld a,0                          ; clear flag
6A56  32AB6A    01187                 ld (action_run),a
                01188 ;               ld iy,sentence
6A59  110600    01189                 ld de,6         ;size of entry
6A5C  DD7E00    01190 @lpBE   ld a,(ix)       ; load verb from table
6A5F  FEFF      01191                 cp 0ffh         ; hit end of table
6A61  CAA36A    01192                 jp z,$xBE 
6A64  FDBE00    01193                 cp (iy)         ; verb match
6A67  C29E6A    01194                 jp nz,$cBE
6A6A  DD7E01    01195                 ld a,(ix+1)
6A6D  FDBE01    01196                 cp (iy+1)                               
6A70  C29E6A    01197                 jp nz,$cBE                      ; d.o.'s don't match
6A73  DD7E02    01198                 ld a,(ix+2)
6A76  FDBE02    01199                 cp (iy+2)               
6A79  C29E6A    01200                 jp nz,$cBE                      ; preps don't match
6A7C  DD7E03    01201                 ld a,(ix+3)
6A7F  FDBE03    01202                 cp (iy+3)               
6A82  C29E6A    01203                 jp nz,$cBE                      ; i.o. 's don't match
6A85  DDE5      01204                 push ix ; ix -> hl
6A87  E1        01205                 pop hl
6A88  23        01206                 inc hl  ; move 4 bytes to sub routine
6A89  23        01207                 inc hl
6A8A  23        01208                 inc hl
6A8B  23        01209                 inc hl
6A8C  5E        01210                 ld e,(hl)
6A8D  23        01211                 inc hl
6A8E  56        01212                 ld d,(hl)
6A8F  D5        01213                 push de ; de -> hl
6A90  E1        01214                 pop hl
6A91  01966A    01215         ld bc,$nxtBE      ; push return addr on stack
6A94  C5        01216                 push bc
6A95  E9        01217                 jp (hl)                 ; return will pop stack
6A96  3E01      01218 $nxtBE  ld a,1
6A98  32AB6A    01219                 ld (action_run),a
6A9B  C3A36A    01220                 jp $xBE                         ; done 
6A9E  DD19      01221 $cBE            add ix,de                       ; skip to next entry 
6AA0  C35C6A    01222                 jp @lpBE
6AA3  FDE1      01223 $xBE            pop iy
6AA5  DDE1      01224                 pop ix
6AA7  E1        01225                 pop hl
6AA8  D1        01226                 pop de
6AA9  C1        01227                 pop bc
6AAA  C9        01228                 ret
                01229 
6AAB  00        01230 action_run DB 0
                01231 *MOD
                01232 run_default_sentence
6AAC  C5        01233                 push bc
6AAD  D5        01234                 push de
6AAE  E5        01235                 push hl
6AAF  DD210000  01236                 ld ix,sentence_table
sentencesZ80.asm(125): undefined symbol
6AB3  110300    01237 $lpBF   ld de,3         ; reload de
6AB6  DD7E00    01238                 ld a,(ix)
6AB9  FEFF      01239                 cp 0ffh ; end?
6ABB  CADB6A    01240                 jp z,$xBF
6ABE  212A68    01241                 ld hl,sentence
6AC1  BE        01242                 cp (hl)         ; equal to verb?
6AC2  C2D66A    01243                 jp nz,$cBF
6AC5  DDE5      01244                 push ix ; ix -> hl
6AC7  E1        01245                 pop hl
6AC8  23        01246                 inc hl          ;skip 1 byte to function address
6AC9  5E        01247                 ld e,(hl)
6ACA  23        01248                 inc hl
6ACB  56        01249                 ld d,(hl)
6ACC  D5        01250                 push de ; de -> hl
6ACD  E1        01251                 pop hl
6ACE  01D36A    01252         ld bc,$nxtBF      ; push return addr on stack
6AD1  C5        01253                 push bc
6AD2  E9        01254                 jp (hl)                 ; return will pop stack
6AD3  110300    01255 $nxtBF  ld de,3         ; reload de
6AD6  DD19      01256 $cBF            add ix,de               ;skip to next
6AD8  C3B36A    01257                 jp $lpBF
6ADB  E1        01258 $xBF            pop hl
6ADC  D1        01259                 pop de
6ADD  C1        01260                 pop bc
6ADE  C9        01261                 ret
                01262 
                01263 
                01264 ;ix contains sentence table addr
                01265 ;if a sentence is run, action_run
                01266 ;is set to 1
                01267 
                01268 *MOD
                01269 run_wildcards
6ADF  F5        01270         push af
6AE0  D5        01271         push de
6AE1  E5        01272         push hl
6AE2  FDE5      01273         push iy
                01274         
6AE4  FD212A68  01275         ld      iy,sentence
                01276         
                01277         ;save old sentence
6AE8  FD7E01    01278         ld  a,(iy+1)
6AEB  326B6B    01279         ld (wildcards+1),a 
6AEE  FD7E03    01280         ld  a,(iy+3)
6AF1  326D6B    01281         ld (wildcards+3),a 
                01282         
                01283 $lpBG   
6AF4  DD7E00    01284                 ld a,(ix)
6AF7  FEFF      01285                 cp 255          ; hit end of table?
6AF9  CA646B    01286                 jp z,$xBG
                01287                 
6AFC  FDBE00    01288                 cp (iy) ; verb match?
6AFF  C2506B    01289                 jp nz, $cBG
                01290                 
6B02  DD7E02    01291                 ld a,(ix+2)
6B05  FDBE02    01292                 cp (iy+2) ; prep match?
6B08  C2506B    01293                 jp nz, $cBG
                01294                 
                01295                 ;does the sentence have a wildcard in the dobj?
6B0B  DD7E01    01296                 ld a,(ix+1)
6B0E  FE00      01297                 cp ANY_OBJECT
sentencesZ80.asm(186): undefined symbol
6B10  C2186B    01298                 jp nz,$skBG
6B13  3EFE      01299                 ld a,254                ; put the '*' in the do
6B15  322B68    01300                 ld (sentence+1),a
                01301 $skBG
                01302                 ;does the sentence have a wildcard in the iobj?
6B18  DD7E03    01303                 ld a,(ix+3)
6B1B  FE00      01304                 cp ANY_OBJECT
sentencesZ80.asm(193): undefined symbol
6B1D  C2256B    01305                 jp nz,$s2BG
6B20  3EFE      01306                 ld a,254                ; put the '*' in the io
6B22  322D68    01307                 ld (sentence+3),a
                01308 $s2BG           
                01309                 ;now see if they match
6B25  DD7E01    01310                 ld a,(ix+1)     ;compare do
6B28  FDBE01    01311                 cp (iy+1)
6B2B  C2506B    01312                 jp nz, $cBG
                01313                 
6B2E  DD7E03    01314                 ld a,(ix+3)     ; compare io
6B31  FDBE03    01315                 cp (iy+3)
6B34  C2506B    01316                 jp nz, $cBG
                01317 
                01318                 ;if here, we have a match       
                01319                 
6B37  DDE5      01320                 push ix ; ix -> hl
6B39  E1        01321                 pop hl
                01322                 
6B3A  23        01323                 inc hl  ; move 4 bytes to sub routine
6B3B  23        01324                 inc hl
6B3C  23        01325                 inc hl
6B3D  23        01326                 inc hl
6B3E  5E        01327                 ld e,(hl)
6B3F  23        01328                 inc hl
6B40  56        01329                 ld d,(hl)
6B41  D5        01330                 push de ; de -> hl
6B42  E1        01331                 pop hl
6B43  01486B    01332         ld bc,$nxtBG      ; push return addr on stack
6B46  C5        01333                 push bc
6B47  E9        01334                 jp (hl)                 ; return will pop stack
6B48  3E01      01335 $nxtBG  ld a,1
6B4A  32AB6A    01336                 ld (action_run),a
6B4D  C3646B    01337                 jp $xBG
                01338                 
                01339 $cBG            ;restore sentence       
6B50  3A6B6B    01340                 ld a,(wildcards+1)
6B53  322B68    01341                 ld (sentence+1),a
                01342                 
6B56  3A6D6B    01343                 ld a,(wildcards+3)
6B59  322D68    01344                 ld (sentence+3),a
                01345                 
6B5C  110600    01346                 ld de,6 ; skip and repeat
6B5F  DD19      01347                 add ix,de 
6B61  C3F46A    01348                 jp $lpBG
                01349                 
6B64  FDE1      01350 $xBG            pop iy
6B66  E1        01351                 pop hl
6B67  D1        01352                 pop de
6B68  F1        01353                 pop af
6B69  C9        01354                 ret
                01355 
                01356         
6B6A  00000000  01357 wildcards DB 0,0,0,0
                01358 *INCLUDE movementZ80.asm
main.asm(91): unable to include file
                01359 *INCLUDE containersZ80.asm
main.asm(92): unable to include file
                01360 *INCLUDE routinesZ80.asm
                01361 ;z80 routines
                01362 
                01363 ;returns property c of object b in register a
                01364 *MOD
                01365 get_obj_attr
6B6E  C5        01366                 push bc
6B6F  D5        01367                 push de
6B70  E5        01368                 push hl
6B71  DDE5      01369                 push ix
6B73  61        01370                 ld h,c  ; save attr in h
6B74  0E00      01371                 ld c,OBJ_ENTRY_SIZE
routinesZ80.asm(11): undefined symbol
6B76  CD386C    01372                 call bmulc
6B79  C5        01373                 push bc ; bc->de
6B7A  D1        01374                 pop de
6B7B  DD210000  01375                 ld ix,obj_table
routinesZ80.asm(15): undefined symbol
6B7F  DD19      01376                 add ix,de        ; add attr offset to ix
6B81  1600      01377                 ld d,0           ; create the attr offset
6B83  5C        01378                 ld e,h  
6B84  DD19      01379                 add ix,de        ; add attr offset to ix
6B86  DD7E00    01380                 ld a,(ix)    ; finally get the byte
6B89  DDE1      01381                 pop ix
6B8B  E1        01382                 pop hl
6B8C  D1        01383                 pop de
6B8D  C1        01384                 pop bc
6B8E  C9        01385                 ret
                01386 
                01387 *MOD
                01388 ;set property c of object b to register a
                01389 set_obj_attr
6B8F  C5        01390                 push bc
6B90  D5        01391                 push de
6B91  E5        01392                 push hl
6B92  DDE5      01393                 push ix
6B94  61        01394                 ld h,c
6B95  0E00      01395                 ld c,OBJ_ENTRY_SIZE
routinesZ80.asm(35): undefined symbol
6B97  CD386C    01396                 call bmulc
6B9A  C5        01397                 push bc
6B9B  D1        01398                 pop de
6B9C  DD210000  01399                 ld ix,obj_table
routinesZ80.asm(39): undefined symbol
6BA0  DD19      01400                 add ix,de        ; add table offset to ix
6BA2  1600      01401                 ld d,0
6BA4  5C        01402                 ld e,h
6BA5  DD19      01403                 add ix,de        ; move to byte
6BA7  DD7700    01404                 ld (ix),a    ; finally get the byte
6BAA  DDE1      01405                 pop ix
6BAC  E1        01406                 pop hl
6BAD  D1        01407                 pop de
6BAE  C1        01408                 pop bc
6BAF  C9        01409                 ret             
                01410                 
                01411 ;returns property c of object b in register a
                01412 ;the property should be 0-15 inclusive
                01413 *MOD
                01414 get_obj_prop
6BB0  C5        01415                 push bc
6BB1  D5        01416                 push de
6BB2  1600      01417                 ld d,PROPERTY_BYTE_1
routinesZ80.asm(57): undefined symbol
6BB4  79        01418                 ld a,c ; get the correct byte
6BB5  59        01419                 ld e,c ; save the prop to get (we need it later) 
6BB6  FE08      01420                 cp 8
6BB8  FABC6B    01421                 jp m,$sBJ ;jump on minus
6BBB  14        01422                 inc d   ; property is in the next byte
6BBC  4A        01423 $sBJ            ld c,d  ; move byte to get to c
6BBD  CD6E6B    01424                 call get_obj_attr ; put attr byte 'c' in 'a'
6BC0  43        01425             ld b,e      ; put prop to test in 'b'
6BC1  CDF26B    01426                 call make_prop_mask ; puts mask from pop 'b' in 'b'
6BC4  A0        01427                 and b ; test the bit in the mask (and leave result in 'a')
6BC5  FE00      01428                 cp 0            ;it it's a zero, leave it
6BC7  CACC6B    01429                 jp z,$xBJ
6BCA  3E01      01430                 ld a,1          ;conver non zero value to 1
6BCC  D1        01431 $xBJ            pop de
6BCD  C1        01432                 pop bc
6BCE  C9        01433                 ret
                01434 
                01435 ;sets property c of object b to val in register 'a'
                01436 ;the property should be 0-15 inclusive
                01437 *MOD
                01438 set_obj_prop
6BCF  C5        01439                 push bc
6BD0  D5        01440                 push de
6BD1  E5        01441                 push hl
6BD2  6F        01442                 ld l,a ; save val
6BD3  1600      01443                 ld d,PROPERTY_BYTE_1
routinesZ80.asm(83): undefined symbol
6BD5  79        01444                 ld a,c ; get the correct byte
6BD6  59        01445                 ld e,c ; save the prop to get (we need it later) 
6BD7  FE08      01446                 cp 8
6BD9  FADD6B    01447                 jp m,$sBK ;jump on minus
6BDC  14        01448                 inc d   ; property is in the next byte
6BDD  4A        01449 $sBK            ld c,d  ; move byte to get to c
6BDE  CD6E6B    01450                 call get_obj_attr ; put attr byte 'c' in 'a'
6BE1  60        01451                 ld h,b  ; save 'b' (the object)
6BE2  43        01452                 ld b,e  ; put prop to test in 'b'
6BE3  CDF26B    01453                 call make_prop_mask ; puts mask from pop 'b' in 'b'
6BE6  B0        01454                 or b ; test the bit in the mask (and leave result in 'a')
6BE7  44        01455                 ld b,h          ; put obj in 'b'
                01456                 ;ld a,b         ; now set it back (val->a)
6BE8  3E01      01457                 ld a,1
6BEA  4A        01458                 ld c,d          ;the byte to store
6BEB  CD8F6B    01459                 call set_obj_attr ;  put a
6BEE  E1        01460 $xBK            pop hl
6BEF  D1        01461                 pop de
6BF0  C1        01462                 pop bc
6BF1  C9        01463                 ret
                01464                 
                01465                 
                01466 ;looks up the mask for the property number in b
                01467 ;mask is returned in 'b'
                01468 ;c is not changed
                01469 make_prop_mask
6BF2  D5        01470         push de
6BF3  E5        01471         push hl
6BF4  FDE5      01472         push iy
6BF6  FD21576C  01473         ld iy,mask_table 
6BFA  1600      01474         ld d,0  
6BFC  58        01475         ld e,b
6BFD  FD19      01476         add iy,de
6BFF  FD2B      01477         dec iy 
6C01  FD4600    01478         ld b,(iy)       ; load mask from table
6C04  FDE1      01479         pop iy
6C06  E1        01480         pop hl
6C07  D1        01481         pop de
6C08  C9        01482         ret
                01483 
                01484 ;player room in 'a'
                01485 get_player_room
6C09  C5        01486                 push bc
6C0A  0600      01487                 ld b,PLAYER_ID  
routinesZ80.asm(127): undefined symbol
6C0C  0E00      01488                 ld c,HOLDER_ID
routinesZ80.asm(128): undefined symbol
6C0E  CD6E6B    01489                 call get_obj_attr
6C11  32376C    01490                 ld (player_room),a
6C14  C1        01491                 pop bc
6C15  C9        01492                 ret
                01493 
                01494 inside_closed_container
6C16  C9        01495                 ret
                01496                 
                01497 ;put 1 or 0 in a if b is an ancestor of c               
                01498 *MOD
                01499 b_ancestor_of_c
6C17  C5        01500                 push bc
6C18  D5        01501                 push de
6C19  50        01502                 ld d,b ; save parent
6C1A  41        01503                 ld b,c ; child object
6C1B  0E00      01504                 ld c,HOLDER_ID
routinesZ80.asm(144): undefined symbol
6C1D  CD6E6B    01505 $lpBL   call get_obj_attr ; puts holder in a
6C20  BA        01506                 cp d            ; ancestor found
6C21  CA326C    01507                 jp z,$yBL
6C24  FE00      01508                 cp 0            ; hit top level - ancestor not found
6C26  CA2D6C    01509                 jp z,$nBL
6C29  47        01510                 ld b,a          ; is b's parent (reg a) a descendant of c
6C2A  C31D6C    01511                 jp $lpBL
6C2D  3E00      01512 $nBL            ld a,0
6C2F  C3346C    01513                 jp $xBL
6C32  3E01      01514 $yBL            ld a,1
6C34  D1        01515 $xBL            pop de
6C35  C1        01516                 pop bc
6C36  C9        01517                 ret
                01518                 
6C37  00        01519 player_room DB 0
                01520 
                01521 ;multiple b x c and puts result in bc
                01522 ;registers are preserved
                01523 *MOD
                01524 bmulc 
6C38  F5        01525                 push af
6C39  D5        01526                 push de
6C3A  DDE5      01527                 push ix
6C3C  1600      01528                 ld d,0 ; add c to b times
6C3E  59        01529                 ld e,c
6C3F  78        01530                 ld a,b ; use  b and loop counter
6C40  DD210000  01531                 ld ix,0
6C44  FE00      01532 $lpBM   cp 0
6C46  CA4F6C    01533                 jp z,$xBM
6C49  DD19      01534                 add ix,de
6C4B  3D        01535                 dec a
6C4C  C3446C    01536                 jp $lpBM
6C4F  DDE5      01537 $xBM            push ix ; ld bc,ix
6C51  C1        01538                 pop bc
6C52  DDE1      01539                 pop ix
6C54  D1        01540                 pop de
6C55  F1        01541                 pop af
6C56  C9        01542                 ret
                01543         
                01544 ;table of mask bytes for looking up
                01545 ;properties of objects          
                01546 mask_table
6C57  00        01547         DB SCENERY_MASK ;equ 1 
routinesZ80.asm(187): undefined symbol
6C58  00        01548         DB SUPPORTER_MASK ;equ 2
routinesZ80.asm(188): undefined symbol
6C59  00        01549         DB CONTAINER_MASK ;equ 4
routinesZ80.asm(189): undefined symbol
6C5A  00        01550         DB TRANSPARENT_MASK ;equ 8
routinesZ80.asm(190): undefined symbol
6C5B  00        01551         DB OPENABLE_MASK ;equ 16
routinesZ80.asm(191): undefined symbol
6C5C  00        01552         DB OPEN_MASK ;equ 32
routinesZ80.asm(192): undefined symbol
6C5D  00        01553         DB LOCKABLE_MASK ;equ 64
routinesZ80.asm(193): undefined symbol
6C5E  00        01554         DB LOCKED_MASK ;equ 128
routinesZ80.asm(194): undefined symbol
6C5F  00        01555         DB PORTABLE_MASK ;equ 1
routinesZ80.asm(195): undefined symbol
6C60  00        01556         DB BACKDROP_MASK ;equ 2
routinesZ80.asm(196): undefined symbol
6C61  00        01557         DB DRINKABLE_MASK ;equ 4
routinesZ80.asm(197): undefined symbol
6C62  00        01558         DB FLAMMABLE_MASK ;equ 8
routinesZ80.asm(198): undefined symbol
6C63  00        01559         DB LIGHTABLE_MASK ;equ 16
routinesZ80.asm(199): undefined symbol
6C64  00        01560         DB LIT_MASK ;equ 32     
routinesZ80.asm(200): undefined symbol
6C65  00        01561         DB DOOR_MASK ;equ 64
routinesZ80.asm(201): undefined symbol
6C66  00        01562         DB UNUSED_MASK ;equ 128
routinesZ80.asm(202): undefined symbol
                01563 
                01564                 
                01565 *INCLUDE inventoryZ80.asm
                01566 ;inventory_sub
                01567 *MOD
                01568 inventory_sub
6C67  F5        01569                 push af
6C68  3E00      01570                 ld a,PLAYER_ID
inventoryZ80.asm(5): undefined symbol
6C6A  CDE26C    01571                 call has_contents
6C6D  FE01      01572                 cp 1
6C6F  C2846C    01573                 jp nz,$nBN
6C72  21436E    01574                 ld hl,carrying
6C75  CD9863    01575             call OUTLIN
6C78  CD9E63    01576                 call printcr
6C7B  00        01577                 nop; recurse through child items
6C7C  3E00      01578                 ld a,PLAYER_ID
inventoryZ80.asm(13): undefined symbol
6C7E  CD8F6C    01579                 call print_contents
6C81  C38D6C    01580                 jp $xBN         
6C84  212D6E    01581 $nBN            ld hl,noitems
6C87  CD9863    01582             call OUTLIN
6C8A  CD9E63    01583                 call printcr
6C8D  F1        01584 $xBN            pop af
6C8E  C9        01585                 ret
                01586 
                01587 ;prints name of a and it's contents of obj in 'a'
                01588 *MOD
                01589 print_contents
6C8F  C5        01590                 push bc
6C90  D5        01591                 push de
6C91  E5        01592                 push hl
6C92  DDE5      01593                 push ix
6C94  47        01594                 ld b,a  ; save parent
6C95  110000    01595                 ld de,OBJ_ENTRY_SIZE
inventoryZ80.asm(30): undefined symbol
6C98  DD210000  01596                 ld ix,obj_table
inventoryZ80.asm(31): undefined symbol
6C9C  DD7E00    01597 $lpBO   ld a,(ix)
6C9F  FEFF      01598                 cp 0ffh
6CA1  CADB6C    01599                 jp z,$xBO
6CA4  DD7E00    01600                 ld a,(ix+HOLDER_ID)
inventoryZ80.asm(35): undefined symbol
6CA7  B8        01601                 cp b
6CA8  C2D66C    01602                 jp nz,$cBO
6CAB  DDCB0046  01603                 bit SCENERY_BIT,(ix+PROPERTY_BYTE_1)  ; test scenery bit
inventoryZ80.asm(38): undefined symbol
6CAF  C2D66C    01604                 jp nz,$cBO
6CB2  DD7E00    01605                 ld a,(ix)
6CB5  CDA26D    01606                 call indent
6CB8  CDCF6D    01607                 call printa
6CBB  CD5F68    01608                 call print_obj_name
6CBE  DD7E00    01609                 ld a,(ix) ; reload obj id
6CC1  CDDA6D    01610                 call append_adj  ; tack on providing light, being worn,...
6CC4  CD9E63    01611                 call printcr
6CC7  00        01612                 nop ; need to test container/supporter
6CC8  DDCB0046  01613                 bit CONTAINER_BIT,(ix+PROPERTY_BYTE_1)
inventoryZ80.asm(48): undefined symbol
6CCC  C4606D    01614                 call nz,print_container_contents
6CCF  DDCB0046  01615                 bit SUPPORTER_BIT,(ix+PROPERTY_BYTE_1)
inventoryZ80.asm(50): undefined symbol
6CD3  C4816D    01616                 call nz,print_supporter_contents
6CD6  DD19      01617 $cBO            add ix,de
6CD8  C39C6C    01618                 jp $lpBO
6CDB  47        01619 $xBO            ld b,a  ; found flag->a
6CDC  DDE1      01620                 pop ix
6CDE  E1        01621                 pop hl
6CDF  D1        01622                 pop de
6CE0  C1        01623                 pop bc          
6CE1  C9        01624                 ret
                01625                 
                01626 ;if 'a' has any visible items
                01627 ;1 is returned in 'a' otherwise 0
                01628 *MOD
                01629 has_contents
6CE2  C5        01630                 push bc
6CE3  D5        01631                 push de
6CE4  E5        01632                 push hl
6CE5  DDE5      01633                 push ix
6CE7  67        01634                 ld h,a  ; holder to 'h'
6CE8  0600      01635                 ld b,0  ; found flag
6CEA  110000    01636                 ld de,OBJ_ENTRY_SIZE
inventoryZ80.asm(71): undefined symbol
6CED  DD210000  01637                 ld ix,obj_table
inventoryZ80.asm(72): undefined symbol
                01638                 
6CF1  DD7E00    01639 $lpBP   ld a,(ix)  ; hit end of table?
6CF4  FEFF      01640                 cp 0ffh
6CF6  CA116D    01641                 jp z,$xBP
                01642                 
6CF9  DD7E00    01643                 ld a,(ix+HOLDER_ID) ; holder matches?
inventoryZ80.asm(78): undefined symbol
6CFC  BC        01644                 cp h
6CFD  C20C6D    01645                 jp nz,$cBP
                01646                 
6D00  DDCB0046  01647                 bit SCENERY_BIT,(ix+PROPERTY_BYTE_1)  ; test scenery bit
inventoryZ80.asm(82): undefined symbol
6D04  C20C6D    01648                 jp nz,$cBP  ; if bit is not zero, continue
                01649                 
6D07  0601      01650                 ld b,1  ; set found flag
6D09  C3116D    01651                 jp $xBP
6D0C  DD19      01652 $cBP            add ix,de
6D0E  C3F16C    01653                 jp $lpBP
6D11  78        01654 $xBP            ld a,b  ; found flag->a
6D12  DDE1      01655                 pop ix
6D14  E1        01656                 pop hl
6D15  D1        01657                 pop de
6D16  C1        01658                 pop bc
6D17  C9        01659                 ret
                01660 *MOD            
                01661 get_sub
6D18  F5        01662                 push af
6D19  C5        01663                 push bc
6D1A  D5        01664                 push de
6D1B  E5        01665                 push hl
6D1C  DDE5      01666                 push ix
6D1E  FDE5      01667                 push iy
                01668 ;               ld a,(sentence+1) ; get dobj
                01669 ;               ld b,a
                01670 ;               ld c,PORTABLE
                01671 ;               call get_obj_prop
                01672 ;               cp 1
                01673 ;               jp z,$y?
                01674 ;               ld hl,notportable
                01675 ;               call OUTLIN
                01676 ;               call printcr
                01677 ;               jp $x? 
                01678 ;$y?            nop ; is it a child of the player already?
                01679 ;               ld a,(sentence+1)
                01680 ;               ld c,a
                01681 ;               ld b,PLAYER_ID
                01682 ;               call b_ancestor_of_c
                01683 ;               cp 0
                01684 ;               jp z,$y1?
                01685 ;               ld hl,alreadyhave
                01686 ;               call OUTLIN
                01687 ;               call printcr
                01688 ;               jp $x?
6D20  00        01689 $y1BQ   nop; move to player
6D21  3A2B68    01690                 ld a,(sentence+1)  ; get dobj
6D24  47        01691                 ld b,a
6D25  0E00      01692                 ld c,HOLDER_ID
inventoryZ80.asm(127): undefined symbol
6D27  3E00      01693                 ld a,PLAYER_ID
inventoryZ80.asm(128): undefined symbol
6D29  CD8F6B    01694                 call set_obj_attr
6D2C  00        01695                 nop ; clear initial description
6D2D  0E00      01696                 ld c,INITIAL_DESC_ID
inventoryZ80.asm(131): undefined symbol
6D2F  3EFF      01697                 ld a,255
6D31  CD8F6B    01698                 call set_obj_attr               
6D34  211D6E    01699                 ld hl,taken
6D37  CD9863    01700                 call OUTLIN
6D3A  CD9E63    01701                 call printcr
6D3D  FDE1      01702 $xBQ            pop iy
6D3F  DDE1      01703                 pop ix
6D41  E1        01704                 pop hl
6D42  D1        01705                 pop de
6D43  C1        01706                 pop bc
6D44  F1        01707                 pop af
6D45  C9        01708                 ret
                01709                 
                01710 *MOD
                01711 drop_sub
6D46  F5        01712                 push af
6D47  C5        01713                 push bc
                01714 ;               nop ; does player have it
                01715 ;               ld a,(sentence+1)
                01716 ;               ld c,a
                01717 ;               ld b,PLAYER_ID
                01718 ;               call b_ancestor_of_c
                01719 ;               cp 1
                01720 ;               jp z,$y?
                01721 ;               ld hl,donthave
                01722 ;               call OUTLIN
                01723 ;               call printcr
                01724 ;               jp $x?
6D48  3A2B68    01725 $yBR            ld a,(sentence+1)
6D4B  47        01726                 ld b,a
6D4C  0E00      01727                 ld c,HOLDER_ID
inventoryZ80.asm(162): undefined symbol
6D4E  CD096C    01728                 call get_player_room
6D51  CD8F6B    01729                 call set_obj_attr
6D54  21246E    01730                 ld hl,dropped
6D57  CD9863    01731                 call OUTLIN
6D5A  CD9E63    01732                 call printcr
6D5D  C1        01733 $xBR            pop bc
6D5E  F1        01734                 pop af
6D5F  C9        01735                 ret
                01736 
                01737 *MOD            
                01738 ;print contents of container in 'a'
                01739 print_container_contents
6D60  C5        01740                 push bc
6D61  E5        01741                 push hl
6D62  47        01742                 ld b,a
6D63  CDE26C    01743                 call has_contents
6D66  FE01      01744                 cp 1
6D68  78        01745                 ld a,b
6D69  C27E6D    01746                 jp nz,$xBS
6D6C  21616E    01747                 ld hl,initis
6D6F  CD9863    01748                 call OUTLIN
6D72  CD9E63    01749                 call printcr
6D75  CDB76D    01750                 call indent_more
6D78  CD8F6C    01751                 call print_contents
6D7B  CDC36D    01752                 call indent_less
6D7E  E1        01753 $xBS            pop hl
6D7F  C1        01754                 pop bc
6D80  C9        01755                 ret
                01756 
                01757 *MOD            
                01758 ;print contents of container in 'a'
                01759 print_supporter_contents
6D81  C5        01760                 push bc
6D82  E5        01761                 push hl
6D83  47        01762                 ld b,a
6D84  CDE26C    01763                 call has_contents
6D87  FE01      01764                 cp 1
6D89  78        01765                 ld a,b
6D8A  C29F6D    01766                 jp nz,$xBT
6D8D  21556E    01767                 ld hl,onitis
6D90  CD9863    01768                 call OUTLIN
6D93  CD9E63    01769                 call printcr
6D96  CDB76D    01770                 call indent_more
6D99  CD8F6C    01771                 call print_contents
6D9C  CDC36D    01772                 call indent_less
6D9F  E1        01773 $xBT            pop hl
6DA0  C1        01774                 pop bc
6DA1  C9        01775                 ret
                01776 
                01777 *MOD    
                01778 indent
6DA2  F5        01779                 push af
6DA3  C5        01780                 push bc
6DA4  3A196E    01781                 ld a,(indentAmt)
6DA7  47        01782                 ld b,a
6DA8  FE00      01783                 cp 0
6DAA  CAB46D    01784                 jp z,$xBU
6DAD  3E20      01785                 ld a,32 ; space
6DAF  CD9463    01786 $lpBU   call CRTBYTE
6DB2  10FB      01787                 djnz $lpBU
6DB4  C1        01788 $xBU            pop bc
6DB5  F1        01789                 pop af
6DB6  C9        01790                 ret
                01791 
                01792 indent_more
6DB7  F5        01793                 push af
6DB8  3A196E    01794                 ld a,(indentAmt)
6DBB  3C        01795                 inc a
6DBC  3C        01796                 inc a
6DBD  3C        01797                 inc a
6DBE  32196E    01798                 ld (indentAmt),a
6DC1  F1        01799                 pop af
6DC2  C9        01800                 ret
                01801                 
                01802 indent_less
6DC3  F5        01803                 push af
6DC4  3A196E    01804                 ld a,(indentAmt)
6DC7  3D        01805                 dec a
6DC8  3D        01806                 dec a
6DC9  3D        01807                 dec a
6DCA  32196E    01808                 ld (indentAmt),a
6DCD  F1        01809                 pop af
6DCE  C9        01810                 ret
                01811 
                01812 
                01813 printa
6DCF  C5        01814                 push bc
6DD0  E5        01815                 push hl
6DD1  211A6E    01816                 ld hl,leadinga
6DD4  CD9863    01817                 call OUTLIN
6DD7  E1        01818                 pop hl
6DD8  C1        01819                 pop bc
6DD9  C9        01820                 ret
                01821 
                01822 ;prints adjectives for object in 'a'
                01823 *MOD
                01824 append_adj
6DDA  C5        01825                 push bc
6DDB  DDE5      01826                 push ix
6DDD  47        01827                 ld b,a
6DDE  0E00      01828                 ld c,OBJ_ENTRY_SIZE
inventoryZ80.asm(263): undefined symbol
6DE0  CD386C    01829                 call bmulc
6DE3  DD210000  01830                 ld ix,obj_table
inventoryZ80.asm(265): undefined symbol
6DE7  DD09      01831                 add ix,bc
6DE9  DDCB0046  01832                 bit LIT_BIT,(ix+PROPERTY_BYTE_2)
inventoryZ80.asm(267): undefined symbol
6DED  CAF66D    01833                 jp z,$xBV
6DF0  21FA6D    01834                 ld hl,providingLight
6DF3  CD9863    01835                 call OUTLIN
6DF6  DDE1      01836 $xBV            pop ix
6DF8  C1        01837                 pop bc
6DF9  C9        01838                 ret
                01839 
6DFA  2850524F  01840 providingLight DB "(PROVIDING LIGHT)",0h
      56 49 44 49 4E 47 20 4C
      49 47 48 54 29 00      
6E0C  28424549  01841 beingWorn DB "(BEING WORN)",0h
      4E 47 20 57 4F 52 4E 29
      00                     
                01842                 
6E19  00        01843 indentAmt DB 0          
6E1A  412000    01844 leadinga DB "A ",0h
6E1D  54414B45  01845 taken DB "TAKEN.",0h            
      4E 2E 00               
6E24  44524F50  01846 dropped DB "DROPPED.",0h
      50 45 44 2E 00         
6E2D  594F5520  01847 noitems DB "YOU ARE EMPTY HANDED.",0h
      41 52 45 20 45 4D 50 54
      59 20 48 41 4E 44 45 44
      2E 00                  
6E43  594F5520  01848 carrying DB "YOU ARE CARRYING:",0h
      41 52 45 20 43 41 52 52
      59 49 4E 47 3A 00      
6E55  4F4E2049  01849 onitis DB "ON IT IS...",0h;
      54 20 49 53 2E 2E 2E 00
6E61  494E2049  01850 initis DB "IN IT IS...",0h;
      54 20 49 53 2E 2E 2E 00
6E6D  594F5520  01851 notportable DB "YOU CAN'T PICK THAT UP.",0h
      43 41 4E 27 54 20 50 49
      43 4B 20 54 48 41 54 20
      55 50 2E 00            
6E85  594F5520  01852 alreadyhave DB "YOU ALREADY HAVE THAT.",0h
      41 4C 52 45 41 44 59 20
      48 41 56 45 20 54 48 41
      54 2E 00               
                01853 
                01854 *INCLUDE open_close.asm
main.asm(95): unable to include file
                01855 *INCLUDE put.asm
main.asm(96): unable to include file
                01856 *INCLUDE miscZ80.asm
main.asm(97): unable to include file
                01857 *INCLUDE print_rets.asm
                01858 ;z80 - print returns
                01859 ;these are long jumped to, not 'called'
                01860 
                01861 print_ret_pardon
6E9C  21E06F    01862         ld hl,pardon
6E9F  CD9863    01863         call OUTLIN
6EA2  CD9E63    01864         call printcr
6EA5  C9        01865         ret
                01866 
                01867 print_ret_no_io
6EA6  21A36F    01868         ld hl,missing_io 
6EA9  CD9863    01869         call OUTLIN
6EAC  CD9E63    01870         call printcr
6EAF  C9        01871         ret
                01872         
                01873         
                01874 print_ret_bad_verb
6EB0  218B6F    01875         ld hl,badverb
6EB3  CD9863    01876         call OUTLIN
6EB6  212467    01877         ld hl,word1
6EB9  CD9863    01878         call OUTLIN
6EBC  21E86F    01879         ld hl,period
6EBF  CD9863    01880         call OUTLIN     
6EC2  CD9E63    01881         call printcr
6EC5  C9        01882         ret
                01883 
                01884 print_ret_bad_do
6EC6  216E6F    01885         ld hl,badnoun
6EC9  CD9863    01886         call OUTLIN
6ECC  214467    01887         ld hl,word2
6ECF  CD9863    01888         call OUTLIN
6ED2  21E86F    01889         ld hl,period
6ED5  CD9863    01890         call OUTLIN     
6ED8  CD9E63    01891         call printcr
6EDB  C9        01892         ret
                01893 
                01894 print_ret_bad_io
6EDC  216E6F    01895         ld hl,badnoun
6EDF  CD9863    01896         call OUTLIN
6EE2  218467    01897         ld hl,word4
6EE5  CD9863    01898         call OUTLIN
6EE8  21E86F    01899         ld hl,period
6EEB  CD9863    01900         call OUTLIN     
6EEE  CD9E63    01901         call printcr
6EF1  C9        01902         ret
                01903 
                01904 print_ret_dont_see
6EF2  21226F    01905         ld hl,dontsee
6EF5  CD9863    01906         call OUTLIN
6EF8  CD9E63    01907         call printcr
6EFB  C9        01908         ret     
                01909 
                01910 print_ret_donthave
6EFC  21366F    01911         ld hl,donthave
6EFF  CD9863    01912         call OUTLIN
6F02  CD9E63    01913         call printcr
6F05  C9        01914         ret
                01915 
                01916 print_ret_not_openable
6F06  214B6F    01917         ld hl,cantopen
6F09  CD9863    01918         call OUTLIN
6F0C  CD9E63    01919         call printcr
6F0F  C9        01920         ret
                01921         
                01922         
                01923         
6F10  49542049  01924 pitchdark DB "IT IS PITCH DARK.",0h
      53 20 50 49 54 43 48 20
      44 41 52 4B 2E 00      
6F22  594F5520  01925 dontsee  DB "YOU DON'T SEE THAT.",0h
      44 4F 4E 27 54 20 53 45
      45 20 54 48 41 54 2E 00
6F36  594F5520  01926 donthave DB "YOU DON'T HAVE THAT.",0h
      44 4F 4E 27 54 20 48 41
      56 45 20 54 48 41 54 2E
      00                     
6F4B  54484154  01927 cantopen DB "THAT'S N0T SOMETHING YOU CAN OPEN.",0h
      27 53 20 4E 30 54 20 53
      4F 4D 45 54 48 49 4E 47
      20 59 4F 55 20 43 41 4E
      20 4F 50 45 4E 2E 00   
6F6E  4920444F  01928 badnoun DB "I DON'T RECOGNIZE THE WORD '",0h ; null     
      4E 27 54 20 52 45 43 4F
      47 4E 49 5A 45 20 54 48
      45 20 57 4F 52 44 20 27
      00                     
6F8B  4920444F  01929 badverb DB "I DON'T KNOW THE VERB '", 0 ; null  
      4E 27 54 20 4B 4E 4F 57
      20 54 48 45 20 56 45 52
      42 20 27 00            
6FA3  4954204C  01930 missing_io DB "IT LOOKS LIKE YOU ARE MISSING THE OBJECT OF THE PREPOSITION.", 0h
      4F 4F 4B 53 20 4C 49 4B
      45 20 59 4F 55 20 41 52
      45 20 4D 49 53 53 49 4E
      47 20 54 48 45 20 4F 42
      4A 45 43 54 20 4F 46 20
      54 48 45 20 50 52 45 50
      4F 53 49 54 49 4F 4E 2E
      00                     
6FE0  50415244  01931 pardon DB "PARDON",3fh,0 ; null
      4F 4E 3F 00            
6FE8  272E00    01932 period DB "'.", 0 ; null
                01933                 
                01934 *INCLUDE EventsZ80.asm
main.asm(99): unable to include file
                01935 *INCLUDE articlesZ80.asm
main.asm(100): unable to include file
                01936 *INCLUDE PrepTableZ80.asm
main.asm(101): unable to include file
                01937 *INCLUDE StringTableZ80.asm
main.asm(102): unable to include file
                01938 *INCLUDE DictionaryZ80.asm
main.asm(103): unable to include file
                01939 *INCLUDE VerbTableZ80.asm
main.asm(104): unable to include file
                01940 *INCLUDE ObjectTableZ80.asm
main.asm(105): unable to include file
                01941 *INCLUDE ObjectWordTableZ80.asm
main.asm(106): unable to include file
                01942 *INCLUDE NogoTableZ80.asm
main.asm(107): unable to include file
                01943 *INCLUDE BackDropTableZ80.asm
main.asm(108): unable to include file
                01944 *INCLUDE before_table_Z80.asm
main.asm(109): unable to include file
                01945 *INCLUDE instead_table_Z80.asm
main.asm(110): unable to include file
                01946 *INCLUDE after_table_Z80.asm
main.asm(111): unable to include file
                01947 *INCLUDE CheckRulesZ80.asm
main.asm(112): unable to include file
                01948 *INCLUDE sentence_tableZ80.asm
main.asm(113): unable to include file
                01949 *INCLUDE WelcomeZ80.asm
main.asm(114): unable to include file
                01950 *INCLUDE sinclair.asm
                01951 ;sinclair
                01952 
                01953 ;BASE equ  3C00H ; address of charset
    = 5800      01954 ATTRS equ 22528  ; address of attr
    = 4000      01955 REGION1 equ 16384
    = 4100      01956 ROW2 equ 16384+256
    = 4800      01957 REGION2 equ 18432
    = 5000      01958 REGION3 equ 20480
                01959 
    = 3C00      01960 ROMCHARS equ 3C00H
    = 5C88      01961 S_POS equ 23688
                01962 
                01963 ;ENTRY :        B=LINE,C=COLUMN 
                01964 ;PRESERVED : BC,DE 
                01965 ;EXIT: HL=ADDRESS IN DISPLAY FILE, A=L 
                01966 
6FEB  78        01967 df_loc  ld      a,b 
6FEC  E6F8      01968                 and     0f8h 
6FEE  C640      01969                 add     a,40h 
6FF0  67        01970                 ld      h,a 
6FF1  78        01971                 ld      a,b 
6FF2  E607      01972                 and     7 
6FF4  0F        01973                 rrca 
6FF5  0F        01974                 rrca 
6FF6  0F        01975                 rrca 
6FF7  81        01976                 add a,c
6FF8  6F        01977                 ld l,a
6FF9  C9        01978                 ret
                01979                 
                01980 ;FINDS ATTR FOR A BYTE IN THE DISP FILE
                01981 ;ENTRY: HL=D.F. ADDRESS 
                01982 ;PRESERVED: HL,BC 
                01983 ;EXIT: DE =ATTR. ADDRESS, A=D 
                01984 df_att 
6FFA  7C        01985                 ld      a,h     
6FFB  0F        01986                 rrca
6FFC  0F        01987                 rrca
6FFD  0F        01988                 rrca
6FFE  E603      01989                 and 3
7000  F658      01990                 or 58h
7002  57        01991                 ld      d,a 
7003  5D        01992                 ld      e,l
7004  C9        01993                 ret                     
                01994                 
                01995 ;ENTRY: B=LINE, C=COLUMN 
                01996 ;PRESERVED: BC 
                01997 ;EXIT: HL=D.F. ADDRESS
                01998 ; DE=ATTR. ADDRESS
                01999 ; A=ATTR(B,C) 
                02000 ;DFCC IS ALTERED stores address to print at in d_file
                02001 locate
7005  78        02002                 ld a,b
7006  E618      02003                 and 18h
7008  67        02004                 ld h,a
7009  CBF4      02005                 set 6,h
700B  0F        02006                 rrca
700C  0F        02007                 rrca
700D  0F        02008                 rrca
700E  F658      02009                 or 58h
7010  57        02010                 ld d,a
7011  78        02011                 ld a,b
7012  E607      02012                 and 7
7014  0F        02013                 rrca
7015  0F        02014                 rrca
7016  0F        02015                 rrca
7017  81        02016                 add a,c
7018  6F        02017                 ld l,a
7019  5F        02018                 ld e,a
701A  1A        02019                 ld a,(de)
701B  220572    02020                 ld (DFCC),hl
701E  C9        02021                 ret
                02022                 
                02023 ;clears screen and attrs
                02024 ;PRESERVED: A ;EXIT: BC-0, DE =5B0H, HL=5AFFH
                02025 cls1 
701F  210040    02026                 ld hl,4000h
7022  010018    02027                 ld bc,1800h
7025  75        02028                 ld (hl),l
7026  54        02029                 ld d,h
7027  1E01      02030                 ld e,1
7029  EDB0      02031                 ldir 
702B  77        02032                 ld (hl),a
702C  01FF02    02033                 ld bc,02ffh
702F  EDB0      02034                 ldir 
7031  C9        02035                 ret             
                02036 
                02037 ;A - CHAR               
                02038 ;prints char in 'a' to          
                02039 *MOD
                02040 print1_zx
7032  F5        02041                         push af
7033  C5        02042                         push bc
7034  D5        02043                         push de
7035  E5        02044                         push hl
                02045         
7036  F5        02046                         push af
7037  CD5E71    02047                         call upd_crs
703A  F1        02048                         pop af
                02049                         
703B  6F        02050                         ld l,a
703C  2600      02051                         ld h,0
703E  29        02052                         add hl,hl
703F  29        02053                         add hl,hl
7040  29        02054                         add hl,hl
7041  ED5B0772  02055                         ld de,(BASE)
7045  19        02056                         add hl,de
                02057                         
                02058                         ;take D_FILE address
7046  ED5B0572  02059                         ld de,(DFCC)
704A  0608      02060                         ld b,8
                02061                         
                02062                         ;print char row by row
704C  7E        02063 $nxtRowBW       ld a,(hl)
704D  12        02064                         ld (de),a
704E  23        02065                         inc hl
704F  14        02066                         inc d
7050  10FA      02067                         djnz $nxtRowBW
                02068 
                02069                         ;construct attr address
7052  7A        02070                         ld a,d
7053  0F        02071                         rrca
7054  0F        02072                         rrca
7055  0F        02073                         rrca
7056  3D        02074                         dec a
7057  E603      02075                         and 3
7059  F658      02076                         or 58h
705B  57        02077                         ld d,a
705C  2A0372    02078                         ld hl,(ATT)
                02079                         ;take old attr
705F  1A        02080                         ld a,(de)
                02081                         
                02082                         ;construct new one
7060  AD        02083                         xor l
7061  A4        02084                         and h
7062  AD        02085                         xor l
                02086                         
                02087                         ;replace attr
7063  12        02088                         ld (de),a
                02089                         
                02090                         ;finally set DFCC to next print pos
7064  210572    02091                         ld hl,DFCC
7067  34        02092                         inc (hl)
7068  C27070    02093                         jp nz,$xBW
706B  23        02094                         inc hl
706C  7E        02095                         ld a,(hl)
706D  C608      02096                         add a,8
706F  77        02097                         ld (hl),a
                02098                         
                02099                         ;update the cursor pos
                02100 $xBW            ;       call upd_crs
7070  E1        02101                         pop hl
7071  D1        02102                         pop de
7072  C1        02103                         pop bc
7073  F1        02104                         pop af
7074  C9        02105                         ret
                02106 
                02107 ;prints str in HL                       
                02108 ;calls print1
                02109 *MOD
                02110 zx_printstr
7075  F5        02111                 push af
7076  C5        02112                 push bc
7077  D5        02113                 push de
7078  E5        02114                 push hl
                02115 
                02116                 ;set the print location based
                02117                 ;on cursor position
7079  CD7671    02118                 call repos_cursor
                02119 
                02120                 ;set src for char data
707C  21003C    02121                 ld hl,3C00h
707F  220772    02122                 ld (BASE),hl
                02123                 
7082  E1        02124                 pop hl
                02125 
                02126                 
7083  7E        02127 $lpBX   ld a,(hl)
7084  FE00      02128                 cp 0
7086  CAAC70    02129                 jp z,$xBX
                02130                 
                02131                 ;will the word fit on the line?
7089  FE20      02132                 cp 32 ; space?
708B  C2A370    02133                 jp nz, $goBX
                02134                 
708E  CDEB71    02135                 call word_len ; word_len -> b
7091  3A0A72    02136                 ld a,(CRSRX)
7094  80        02137                 add a,b
7095  FE1F      02138                 cp 31
7097  FAA170    02139                 jp m,$spBX
                02140                 
                02141                 ;replace the space with a newline
709A  CDB070    02142                 call zx_newline
709D  23        02143                 inc hl  ; skip space
709E  C38370    02144                 jp $lpBX
                02145                 
                02146                 
70A1  3E20      02147 $spBX   ld a,32 ; reload space
                02148 
70A3  E5        02149 $goBX   push hl
70A4  CD3270    02150                 call print1_zx ; 
70A7  E1        02151                 pop hl
70A8  23        02152                 inc hl
70A9  C38370    02153                 jp $lpBX
                02154                 
                02155 $xBX             
70AC  D1        02156                 pop de
70AD  C1        02157                 pop bc
70AE  F1        02158                 pop af
70AF  C9        02159                 ret
                02160 
                02161 
                02162 *MOD
                02163 zx_newline
70B0  E5        02164                 push hl
70B1  3E00      02165                 ld a,0                  ;back to left
70B3  320A72    02166                 ld (CRSRX),a
70B6  3A0972    02167                 ld a,(CRSRY)    ;down (if room)
70B9  FE17      02168                 cp 23
70BB  CAC570    02169                 jp z,$sclBY
70BE  3C        02170                 inc a
70BF  320972    02171                 ld (CRSRY),a                            
70C2  C3C870    02172                 jp $xBY
70C5  CDCD70    02173 $sclBY  call zx_scroll
70C8  CD7671    02174 $xBY    call repos_cursor
70CB  E1        02175                 pop hl
70CC  C9        02176                 ret
                02177 
                02178 ;scrolls lines up, but leaves the top line
                02179 ;with the room and the score intact
                02180 ;notes, screen is in three chunks
                02181 ;
                02182 *MOD
                02183 zx_scroll
                02184                 
70CD  3E06      02185                 ld a,6
70CF  320E72    02186                 ld (SCROLL_LPS),a
70D2  110041    02187                 ld de,ROW2; 
70D5  CDFD70    02188                 call scroll_rgn
                02189 
70D8  3E07      02190                 ld a,7
70DA  320E72    02191                 ld (SCROLL_LPS),a
70DD  110048    02192                 ld de,REGION2
70E0  CDFD70    02193                 call scroll_rgn
                02194                 
70E3  3E07      02195                 ld a,7
70E5  320E72    02196                 ld (SCROLL_LPS),a
70E8  110050    02197                 ld de,REGION3
70EB  CDFD70    02198                 call scroll_rgn
                02199  
70EE  01C002    02200                 ld bc,704 ; scroll attrs
70F1  214058    02201                 ld hl,ATTRS+64
70F4  112058    02202                 ld de,ATTRS+32
70F7  EDB0      02203                 ldir ; hl->de repeating         
                02204                 
70F9  CD8171    02205                 call clr_btm_line
                02206 
70FC  C9        02207                 ret 
                02208 
                02209 *MOD
                02210 ;de =start addr of bank
                02211 ;scrolls a region of the screen, up one 
                02212 ;line of chars
                02213 scroll_rgn
                02214 
70FD  ED530B72  02215                 ld (SCROLLTEMP),de
                02216                                 
7101  3A0B72    02217                 ld a,(SCROLLTEMP) ;don't copy 1st 
7104  FE40      02218                 cp 40h                    ;bank down - 1st
7106  CA2F71    02219                 jp z,$cpyCA     ;starts at 4000h
                02220                   
                02221                 ;copy eight lines (for 1st row) into
                02222                 ;the last lines in the previous bank
                02223                 ;the byte difference will be
                02224                 ; 2k -(7x32) = 1824 bytes
                02225 
7109  2A0B72    02226                 ld hl,(SCROLLTEMP)
710C  3E08      02227                 ld a,8 ; rows to copy
                02228                 
710E  112007    02229                 ld de,1824
7111  A7        02230                 and a ; clr carry
7112  ED52      02231                 sbc hl,de
7114  E5        02232                 push hl ; hl->de
7115  D1        02233                 pop de 
                02234                 
7116  2A0B72    02235                 ld hl,(SCROLLTEMP) ; src
7119  012000    02236 $lpCA   ld bc,32 ; bytes per row
711C  EDB0      02237                 ldir ; hl->de
                02238                 
                02239                 ;add 224 to de and hl
                02240                 ;to get to the next line 
                02241                 ;of pixels to copy
711E  E5        02242                 push hl  ; save hl
                02243                 
711F  01E000    02244                 ld bc,224
7122  D5        02245                 push de ; de->hl
7123  E1        02246                 pop hl
7124  09        02247                 add hl,bc       
7125  E5        02248                 push hl ; hl->de
7126  D1        02249                 pop de
                02250                 
7127  E1        02251                 pop hl ; restore hl
                02252                 
7128  09        02253                 add hl,bc
                02254                 
                02255                 ;loop
7129  3D        02256                 dec a
712A  FE00      02257                 cp 0
712C  C21971    02258                 jp nz,$lpCA
                02259                                 
                02260                 ;copy 7 rows of 32 chars
712F  3A0E72    02261 $cpyCA  ld a,(SCROLL_LPS)
                02262 $lp2CA          
7132  2A0B72    02263                 ld hl,(SCROLLTEMP)
7135  ED5B0B72  02264                 ld de,(SCROLLTEMP)
7139  012000    02265                 ld bc,32
713C  09        02266             add hl,bc ; copy from 3rd row
                02267                 
713D  E5        02268                 push hl ; hl is set up, save it
                02269                 
713E  2A0B72    02270                 ld hl,(SCROLLTEMP)
7141  010000    02271                 ld bc,0
7144  09        02272                 add hl,bc ; ...to 2nd row
                02273                 
7145  E5        02274                 push hl ; hl->de
7146  D1        02275                 pop de
                02276                 
7147  E1        02277                 pop hl ; restore hl
                02278                 
7148  01E000    02279                 ld bc,224 ; times to loop
714B  EDB0      02280                 ldir ; hl->de
                02281                 
                02282                 ;advance scroll temp to next 
                02283                 ;block of bytes
714D  2A0B72    02284                 ld hl,(SCROLLTEMP)
7150  010001    02285                 ld bc,256
7153  09        02286                 add hl,bc
7154  220B72    02287                 ld (SCROLLTEMP),hl
                02288                 
                02289                 ;loop
7157  3D        02290                 dec a
7158  FE00      02291                 cp 0
715A  C23271    02292                 jp nz,$lp2CA
                02293                 
715D  C9        02294                 ret
                02295                 
                02296 ;moves the cursor position       
                02297 ;this should be called by print1
                02298 
                02299 *MOD
                02300 upd_crs
715E  3A0A72    02301         ld a,(CRSRX)
7161  3C        02302         inc a
7162  320A72    02303         ld (CRSRX),a
7165  FE20      02304         cp 32d
7167  C27571    02305         jp nz,$xCB
                02306         
716A  3A0D72    02307         ld a,(NOSCROLL)
716D  FE01      02308         cp 1
716F  CA7571    02309         jp z,$xCB
7172  CDB070    02310         call zx_newline
                02311          
7175  C9        02312 $xCB ret                
                02313                         
                02314 
                02315 ;reset the 'print at' position          
                02316 repos_cursor
7176  ED4B0972  02317         ld bc,(CRSRY) ; grabs x,y
717A  78        02318         ld a,b
717B  41        02319         ld b,c
717C  4F        02320         ld c,a
717D  CD0570    02321         call locate             
7180  C9        02322         ret
                02323 
                02324 *MOD    
                02325 clr_btm_line
                02326 
7181  3E01      02327                 ld a,1
7183  320D72    02328                 ld (NOSCROLL),a
                02329                 
7186  3E00      02330                 ld a,0
7188  320A72    02331                 ld (CRSRX),a
718B  3E17      02332                 ld a,23
718D  320972    02333                 ld (CRSRY),a
7190  CD7671    02334                 call repos_cursor
                02335                 
7193  3E20      02336                 ld a,32  ; 32 spaces
                02337                 
7195  F5        02338 $lpCC   push af
7196  3E20      02339                 ld a,32  ; ascii space
7198  CD3270    02340                 call print1_zx
719B  F1        02341                 pop af
719C  3D        02342                 dec a
719D  FE00      02343                 cp 0
719F  C29571    02344                 jp nz,$lpCC
                02345                 
71A2  3E00      02346                 ld a,0
71A4  320A72    02347                 ld (CRSRX),a
71A7  3E17      02348                 ld a,23
71A9  320972    02349                 ld (CRSRY),a
71AC  CD7671    02350                 call repos_cursor
                02351 
71AF  3E00      02352                 ld a,0
71B1  320D72    02353                 ld (NOSCROLL),a
                02354                 
71B4  C9        02355                 ret
                02356 
                02357 ;This is the 'delete' key function
                02358 *MOD            
                02359 back_up
                02360         ;are we all the way left?
71B5  3A0A72    02361         ld a,(CRSRX)
71B8  FE01      02362         cp 1
71BA  CAEA71    02363         jp z,$xCD
                02364         
                02365         ;back up
71BD  3A0A72    02366         ld a,(CRSRX)
71C0  3D        02367         dec a
71C1  320A72    02368         ld (CRSRX),a
71C4  CD7671    02369         call repos_cursor
                02370 
                02371         ;back up buffer index
71C7  3A8862    02372         ld a,(BUFIX)
71CA  3D        02373         dec a
71CB  328862    02374         ld (BUFIX),a
                02375         
                02376         ;overwrite character
71CE  1600      02377         ld d,0
71D0  3A8862    02378         ld a,(BufIx)
71D3  5F        02379         ld e,a
71D4  218962    02380         ld hl,InBuf
71D7  19        02381         add hl,de
71D8  3E00      02382         ld a,0
71DA  77        02383         ld (hl),a
                02384         
                02385         
                02386                 
                02387         ;print a space
71DB  3E20      02388         ld a,32 
71DD  CD3270    02389         call print1_zx
                02390         
                02391         ;back up again
71E0  3A0A72    02392         ld a,(CRSRX)
71E3  3D        02393         dec a
71E4  320A72    02394         ld (CRSRX),a
71E7  CD7671    02395         call repos_cursor
                02396         
71EA  C9        02397 $xCD    ret
                02398 
                02399 *MOD
                02400 ;returns the length of the word indexed 
                02401 ;by hl in register b
                02402 ;other registers are preserved.
                02403 ;assumes (hl) points to a space
                02404 *MOD
                02405 word_len
71EB  F5        02406         push af
71EC  E5        02407         push hl
                02408         
71ED  23        02409         inc hl  
71EE  0601      02410         ld b,1
                02411 $lpCF
71F0  7E        02412         ld a,(hl)
                02413         
71F1  FE00      02414     cp 0  ; null
71F3  CA0072    02415         jp z,$xCF
                02416 
71F6  FE20      02417     cp 32  ; space
71F8  CA0072    02418         jp z,$xCF        
                02419 
71FB  04        02420         inc b
71FC  23        02421         inc hl
71FD  C3F071    02422         jp $lpCF
                02423 
7200  E1        02424 $xCF    pop hl
7201  F1        02425         pop af
7202  C9        02426         ret
                02427 
                02428                 
7203  38        02429 ATT DB 38h ; 
7204  00        02430 MASK DB 0 ; Attribute mask for printing 
7205  A00F      02431 DFCC DW 4000 ; DF Address of cell x,y (set by locate sub)
7207  003C      02432 BASE DW 3C00h
7209  00        02433 CRSRY DB 0
720A  00        02434 CRSRX DB 0
720B  0000      02435 SCROLLTEMP DW 0
720D  00        02436 NOSCROLL DB 0
720E  07        02437 SCROLL_LPS DB 7 ; how many rows to move
720F  3E        02438 curstr DB ">"
7210  00        02439         DB 0
                02440 
                02441 *INCLUDE math.asm
main.asm(116): unable to include file
                02442 *INCLUDE UserVarsZ80.asm
main.asm(117): unable to include file
                02443 
7211  00        02444 score DB 0
7212  00        02445 gameOver DB 0
7213  00        02446 moves DB 0
7214  00        02447 turnsWithoutLight DB 0
7215  64        02448 health DB 100
                02449 
7216  54484953  02450 msg db "THIS IS A MESSAGE",0h           
      20 49 53 20 41 20 4D 45
      53 53 41 47 45 00      
                02451         
                02452         end start


$CBC            69FE  $CBE            6A9E  $CBF            6AD6  
$CBG            6B50  $CBO            6CD6  $CBP            6D0C  
$CNTL           65DC  $CPYCA          712F  $CW             6913  
$DBC            6A07  $DOQ            667D  $GO?            61E1  
$GOBX           70A3  $INP?           61C9  $IOQ            66A3  
$LP             65AE  $LP2A           6215  $LP2CA          7132  
$LPBA           69AA  $LPBC           69DE  $LPBF           6AB3  
$LPBG           6AF4  $LPBL           6C1D  $LPBM           6C44  
$LPBO           6C9C  $LPBP           6CF1  $LPBU           6DAF  
$LPBX           7083  $LPC            626C  $LPCA           7119  
$LPCC           7195  $LPCF           71F0  $LPF            63C2  
$LPG            6421  $LPJ            6501  $LPW            68ED  
$LPX            693A  $LPY            696D  $NBA            69C5  
$NBL            6C2D  $NBN            6C84  $NFW            6924  
$NXTBC          69FC  $NXTBE          6A96  $NXTBF          6AD3  
$NXTBG          6B48  $NXTROWBW       704C  $OUTA           6247  
$PRINT_PARDONH  64C8  $S2BG           6B25  $SA             6226  
$SBJ            6BBC  $SBK            6BDD  $SCD            6284  
$SCLBY          70C5  $SKBG           6B18  $SPBX           70A1  
$W4P            664E  $X?             620B  $XA             624A  
$XBA            69C7  $XBB            69D9  $XBD            6A48  
$XBE            6AA3  $XBF            6ADB  $XBG            6B64  
$XBJ            6BCC  $XBK            6BEE  $XBL            6C34  
$XBM            6C4F  $XBN            6C8D  $XBO            6CDB  
$XBP            6D11  $XBQ            6D3D  $XBR            6D5D  
$XBS            6D7E  $XBT            6D9F  $XBU            6DB4  
$XBV            6DF6  $XBW            7070  $XBX            70AC  
$XBY            70C8  $XCB            7175  $XCD            71EA  
$XCF            7200  $XD             6286  $XG             643C  
$XI             64F9  $XJ             653C  $XK             6569  
$XL             65E1  $XP             6663  $XQ             66C5  
$XS             66FE  $XX             695F  $XY             6978  
$Y1BQ           6D20  $Y?             6206  $YBA            69C0  
$YBL            6C32  $YBR            6D48  $YK             656C  
$_LP            65CC  $_LPM           65E8  $_LPV           68B6  
$_NFV           68DC  $_X             6605  $_XH            64C7  
$_XV            68DE  $_XW            6926  $_XZ            699F  
$_YW            691E  @LPBE           6A5C  ACTIONS_TABLE   0000  
ACTION_RUN      6AAB  ALREADYHAVE     6E85  ANY_OBJECT      0000  
APPEND_ADJ      6DDA  ARTICLE_TABLE   0000  ATOUPPER        69CD  
ATT             7203  ATTRS           5800  AUTHOR          0000  
BACKDROP_MASK   0000  BACKUP_2        6440  BACK_UP         71B5  
BADNOUN         6F6E  BADVERB         6F8B  BASE            7207  
BEINGWORN       6E0C  BMULC           6C38  BUFIX           6288  
BUFSIZE         0030  B_ANCESTOR_OF_C 6C17  CANTOPEN        6F4B  
CARRYING        6E43  CHECK_TABLE     0000  CLEAR_BUFFERS   6595  
CLRBUF          6262  CLR_BTM_LINE    7181  CLS1            701F  
CONTAINER_BIT   0000  CONTAINER_MASK  0000  COPYDEST        6824  
CRSRX           720A  CRSRY           7209  CRTBYTE         6394  
CURMODE         5CD1  CURSTR          720F  DBGPF           6700  
DBGSA           670F  DELETE          000C  DFCC            7205  
DF_ATT          6FFA  DF_LOC          6FEB  DICTIONARY      0000  
DIV             0000  DONTHAVE        6F36  DONTSEE         6F22  
DOOR_MASK       0000  DOWORDID        6830  DO_EVENTS       61F4  
DRAW_TOP_BAR    63AF  DRINKABLE_MASK  0000  DROPPED         6E24  
DROP_SUB        6D46  ENCODE          66E6  FIND_PREPOSITIO 64FD  
FLAMMABLE_MASK  0000  GAMEOVER        7212  GETCOMMAND      61D9  
GETLIN          620C  GET_OBJ_ATTR    6B6E  GET_OBJ_ID      68E0  
GET_OBJ_PROP    6BB0  GET_PLAYER_ROOM 6C09  GET_SUB         6D18  
GET_TABLE_INDEX 68B3  GET_VERBS_ID    692B  HANDLE_PREP     6541  
HAS_CONTENTS    6CE2  HEALTH          7215  HIT_END         6828  
HOLDER_ID       0000  HUNDRED         6451  INBUF           6289  
INDENT          6DA2  INDENTAMT       6E19  INDENT_LESS     6DC3  
INDENT_MORE     6DB7  INITIAL_DESC_ID 0000  INITIS          6E61  
INSIDE_CLOSED_C 6C16  INVENTORY_SUB   6C67  IOWORDID        6831  
LEADINGA        6E1A  LIGHTABLE_MASK  0000  LIT_BIT         0000  
LIT_MASK        0000  LKP_DIRECTOBJ   66C6  LKP_INDIRECTOBJ 66D6  
LOCATE          7005  LOCKABLE_MASK   0000  LOCKED_MASK     0000  
LOOK_SUB        0000  LOOP            638E  LPZ             698A  
MAIN            61A8  MAKE_PROP_MASK  6BF2  MASK            7204  
MASK_TABLE      6C57  MISSING_IO      6FA3  MOD             0000  
MOVES           7213  MOVE_PREP       6571  MOVE_TO_END     65E7  
MOVE_TO_NEXT    65BA  MOVE_TO_START   65CB  MSG             7216  
NOITEMS         6E2D  NOSCROLL        720D  NOTPORTABLE     6E6D  
OBJ_ENTRY_SIZE  0000  OBJ_TABLE       0000  OBJ_WORD_TABLE  0000  
ONITIS          6E55  OPENABLE_MASK   0000  OPEN_MASK       0000  
OUTLIN          6398  OUTLINCR        624B  PARDON          6FE0  
PARSE           6456  PARSE_ERR       682F  PERIOD          6FE8  
PITCHDARK       6F10  PLAYER_HAS_LIGH 0000  PLAYER_ID       0000  
PLAYER_ROOM     6C37  PORTABLE_MASK   0000  POSTACTIONS_TAB 0000  
PREACTIONS_TABL 0000  PREPADDR        6826  PREP_FOUND      682E  
PREP_TABLE      0000  PRINT1_ZX       7032  PRINTA          6DCF  
PRINTCR         639E  PRINT_CONTAINER 6D60  PRINT_CONTENTS  6C8F  
PRINT_OBJ_NAME  685F  PRINT_RET_BAD_D 6EC6  PRINT_RET_BAD_I 6EDC  
PRINT_RET_BAD_V 6EB0  PRINT_RET_DONTH 6EFC  PRINT_RET_DONT_ 6EF2  
PRINT_RET_NOT_O 6F06  PRINT_RET_NO_IO 6EA6  PRINT_RET_PARDO 6E9C  
PRINT_SCORE     63FF  PRINT_SPACE     68A5  PRINT_SUPPORTER 6D81  
PRINT_TABLE_ENT 6832  PROMPT          003E  PROPERTY_BYTE_1 0000  
PROPERTY_BYTE_2 0000  PROVIDINGLIGHT  6DFA  READKB          6389  
READ_DOBJ       6607  REGION1         4000  REGION2         4800  
REGION3         5000  REPOS_CURSOR    7176  ROMCHARS        3C00  
ROW2            4100  RUN_ACTIONS     6A26  RUN_ACTIONS_    6A4D  
RUN_DEFAULT_SEN 6AAC  RUN_SENTENCE    69DA  RUN_WILDCARDS   6ADF  
SCENERY_BIT     0000  SCENERY_MASK    0000  SCORE           7211  
SCRCOLOR        5C8D  SCREEN          4000  SCROLLTEMP      720B  
SCROLL_LPS      720E  SCROLL_RGN      70FD  SCRSIZE         02BE  
SENTENCE        682A  SENTENCE_TABLE  0000  SET_OBJ_ATTR    6B8F  
SET_OBJ_PROP    6BCF  SKIP_ARTICLE    64CD  START           61A8  
STORE_WORD      661D  STRCPY          697B  STRCPYI         6985  
STREQ           69A5  STRLEN          6968  SUPPORTER_BIT   0000  
SUPPORTER_MASK  0000  S_POS           5C88  TAKEN           6E1D  
TRANSPARENT_MAS 0000  TURNSWITHOUTLIG 7214  UNUSED_MASK     0000  
UPD_CRS         715E  VALIDATE_ENCODE 6639  VALIDATE_WORDS  6664  
VERB_TABLE      0000  VERSION         0000  WELCOME         0000  
WILDCARDS       6B6A  WORD1           6724  WORD2           6744  
WORD3           6764  WORD4           6784  WORD5           67A4  
WORD6           67C4  WORD7           67E4  WORD8           6804  
WORD_COUNT      6829  WORD_LEN        71EB  ZX_NEWLINE      70B0  
ZX_PRINTSTR     7075  ZX_SCROLL       70CD  ZX_TO_ASCII     6275  
_HEM            6600  _L2$            687A  _LP             683A  
_LP$            686B  _OUT$           6876  _SK             6849  
_X              6858  _XU             689F  
